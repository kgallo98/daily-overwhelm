<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Daily Overwhelm</title>

    <!-- PWA setup -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Overwhelm">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        * {
            box-sizing: border-box;
        }

        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --text-muted: #aaa;
            --text-light: #bbb;
            --border-color: #333;
            --input-bg: #0f0f23;
            --shadow: rgba(0,0,0,0.3);
            --accent: #4a90a4;
            --done-color: #5cb85c;
            --later-color: #f0ad4e;
        }

        /* Bedtime mode - warmer, softer colors */
        body.bedtime-mode {
            --bg-color: #1a1610;
            --card-bg: #2a2018;
            --text-color: #e8dcc8;
            --text-muted: #a89880;
            --text-light: #c8b8a0;
            --border-color: #3a3028;
            --input-bg: #1a1610;
            --accent: #c4956a;
        }

        body.bedtime-mode #big-mic-button {
            box-shadow: 0 4px 20px rgba(196, 149, 106, 0.3);
        }

        body.bedtime-mode .ripple {
            border-color: var(--accent);
        }

        /* Top buttons */
        #bedtime-toggle, #settings-toggle {
            position: fixed;
            top: 15px;
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            z-index: 50;
            opacity: 0.6;
            transition: opacity 0.2s;
            padding: 8px;
        }

        #bedtime-toggle { right: 15px; }
        #settings-toggle { left: 15px; }

        #bedtime-toggle:hover, #settings-toggle:hover {
            opacity: 1;
        }

        /* Settings panel */
        #settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-color);
            z-index: 200;
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            padding: 20px;
            padding-top: 60px;
        }

        #settings-panel.visible {
            transform: translateX(0);
        }

        #settings-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
        }

        #settings-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 30px;
            color: var(--text-color);
        }

        .settings-section {
            margin-bottom: 30px;
        }

        .settings-section-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 15px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-item-label {
            font-size: 16px;
            color: var(--text-color);
        }

        .settings-item-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .toggle-switch input:disabled + .toggle-slider {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-coming-soon {
            font-size: 11px;
            color: var(--accent);
            margin-left: 10px;
        }

        /* Hide text input in bedtime mode */
        body.bedtime-mode #text-input-section {
            display: none;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        /* Tab content */
        #tabs-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;
        }

        #tabs-track {
            display: flex;
            height: 100%;
            will-change: transform;
        }

        #tabs-track.animating {
            transition: transform 0.3s ease-out;
        }

        .tab-content {
            flex: none;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            width: 100vw;
            min-width: 100vw;
        }

        /* ===== CAPTURE TAB ===== */
        #capture-tab {
            position: relative;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #mic-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #big-mic-button {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background-color: var(--accent);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 4px 20px rgba(74, 144, 164, 0.4);
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
            position: relative;
            z-index: 2;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 0.5px;
            text-transform: lowercase;
        }

        #big-mic-button:active {
            transform: scale(0.98);
        }

        #big-mic-button.listening {
            background-color: #e74c3c;
            box-shadow: 0 4px 30px rgba(231, 76, 60, 0.5);
            animation: pulse-listening 1s infinite;
        }

        .ripple {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 1px solid var(--accent);
            opacity: 0;
            z-index: 1;
            pointer-events: none;
        }

        .ripple-1 { animation: ripple 7s ease-out infinite; }
        .ripple-2 { animation: ripple 7s ease-out infinite 2s; }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 0.4; }
            57% { transform: scale(1.8); opacity: 0; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        @keyframes pulse-listening {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #mic-container.listening .ripple {
            animation: none;
            opacity: 0;
        }

        #capture-confirmation {
            margin-top: 30px;
            padding: 12px 24px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 20px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: 0.3px;
            opacity: 0;
            transform: scale(0.9) translateY(10px);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        #capture-confirmation.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        /* Capture success flash on button */
        #big-mic-button.captured {
            animation: capture-flash 0.4s ease-out;
        }

        @keyframes capture-flash {
            0% { transform: scale(1); }
            30% { transform: scale(0.95); }
            60% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        #text-input-section {
            position: absolute;
            bottom: 80px;
            left: 20px;
            right: 20px;
            max-width: 300px;
            margin: 0 auto;
        }

        #thought-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-color);
            text-align: center;
        }

        #thought-input::placeholder {
            color: var(--text-muted);
        }

        /* Swipe hint at bottom of capture tab */
        #capture-swipe-hint {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: var(--text-muted);
            opacity: 0.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        #capture-swipe-hint .hint-chevron {
            width: 20px;
            height: 20px;
            opacity: 0.5;
            animation: hint-bounce 2s ease-in-out infinite;
        }

        @keyframes hint-bounce {
            0%, 100% { transform: translateY(0); opacity: 0.5; }
            50% { transform: translateY(-4px); opacity: 0.8; }
        }

        /* ===== FOCUS OVERLAY (swipe up from capture) ===== */
        #focus-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-color);
            z-index: 100;
            transform: translateY(100%);
            display: flex;
            flex-direction: column;
            will-change: transform;
        }

        #focus-overlay.animating {
            transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
        }

        #focus-overlay.visible {
            transform: translateY(0);
        }

        #focus-handle {
            padding: 15px;
            display: flex;
            justify-content: center;
            cursor: grab;
        }

        #focus-handle:active {
            cursor: grabbing;
        }

        .handle-pill {
            width: 36px;
            height: 4px;
            background-color: var(--text-muted);
            border-radius: 2px;
            opacity: 0.4;
        }

        #focus-cards-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 30px;
            gap: 14px;
            overflow: hidden;
        }

        #focus-message {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 20px;
        }

        #focus-message-title {
            font-size: 22px;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 8px;
        }

        #focus-message-subtitle {
            font-size: 15px;
            color: var(--text-muted);
        }

        /* Focus card wrapper */
        .focus-card-wrapper {
            position: relative;
            flex: 1;
            max-height: 140px;
            min-height: 80px;
            border-radius: 16px;
            overflow: hidden;
            transition: flex 0.3s ease-out, opacity 0.3s ease-out, max-height 0.3s ease-out;
        }

        .focus-card-wrapper.removing {
            flex: 0;
            max-height: 0;
            opacity: 0;
            margin: 0;
        }

        /* Swipe backgrounds */
        .swipe-bg {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: lowercase;
            color: white;
            opacity: 0;
            transition: opacity 0.15s;
            border-radius: 16px;
        }

        .swipe-bg-left {
            background: linear-gradient(135deg, var(--later-color), #e09530);
            justify-content: flex-end;
        }

        .swipe-bg-right {
            background: linear-gradient(135deg, #4caf50, var(--done-color));
            justify-content: flex-start;
        }

        /* Focus card */
        .focus-card {
            position: relative;
            height: 100%;
            background-color: var(--card-bg);
            border-radius: 16px;
            padding: 20px 24px;
            padding-left: 22px;
            display: flex;
            align-items: center;
            touch-action: pan-y pinch-zoom;
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 3px solid var(--accent);
            overflow: hidden;
        }

        .focus-card:active {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .focus-card.swiping {
            transition: none;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }

        .focus-card-text {
            font-size: 18px;
            color: var(--text-color);
            line-height: 1.45;
            flex: 1;
            font-weight: 450;
            position: relative;
            z-index: 1;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* ===== TODAY TAB ===== */
        #today-tab {
            padding-top: 50px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.2px;
            margin-bottom: 12px;
            margin-top: 28px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item {
            padding: 14px 16px;
            background-color: var(--card-bg);
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.4;
            color: var(--text-color);
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .task-item.tappable {
            cursor: pointer;
        }

        .task-item.tappable:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .task-item.later {
            border-left: 3px solid var(--later-color);
        }

        .task-item.completed {
            border-left: 3px solid var(--done-color);
            color: var(--text-light);
        }

        .task-item.old {
            border-left: 3px solid var(--text-muted);
            opacity: 0.85;
        }

        .task-item-age {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .empty-section {
            color: var(--text-muted);
            font-size: 14px;
            padding: 20px;
            text-align: center;
            opacity: 0.6;
        }

        /* ===== ALL TAB ===== */
        #all-tab {
            padding-top: 50px;
        }

        /* ===== PATTERNS TAB ===== */
        #patterns-tab {
            padding-top: 50px;
        }

        .pattern-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .pattern-card-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .pattern-card-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-color);
        }

        .pattern-card-detail {
            font-size: 14px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .pattern-row {
            display: flex;
            gap: 12px;
        }

        .pattern-row .pattern-card {
            flex: 1;
        }

        .pattern-bar-container {
            margin-top: 12px;
        }

        .pattern-bar-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .pattern-bar-label {
            width: 40px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .pattern-bar-track {
            flex: 1;
            height: 8px;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .pattern-bar-fill {
            height: 100%;
            background-color: var(--accent);
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }

        .backlog-item-wrapper {
            position: relative;
            margin-bottom: 10px;
            border-radius: 10px;
            overflow: hidden;
        }

        .backlog-item-wrapper.removing {
            transition: max-height 0.3s, opacity 0.3s, margin 0.3s;
            max-height: 0;
            opacity: 0;
            margin: 0;
            overflow: hidden;
        }

        .backlog-swipe-bg {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 500;
            color: white;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .backlog-swipe-delete {
            background-color: #e74c3c;
            justify-content: flex-end;
        }

        .backlog-swipe-delete.confirm {
            justify-content: center;
            cursor: pointer;
        }

        .backlog-item {
            padding: 14px 16px;
            background-color: var(--card-bg);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            touch-action: pan-y pinch-zoom;
            transition: transform 0.1s, box-shadow 0.1s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .backlog-item.swiping {
            transition: none;
        }

        .backlog-item.dragging {
            opacity: 0.9;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 10;
            transform: scale(1.02);
        }

        .backlog-item-text {
            font-size: 15px;
            line-height: 1.4;
            color: var(--text-color);
            flex: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
            min-width: 0;
        }

        .backlog-item-meta {
            font-size: 11px;
            color: var(--text-muted);
            margin-left: 12px;
            white-space: nowrap;
        }

        .backlog-placeholder {
            background-color: var(--border-color);
            border-radius: 10px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* ===== TAB BAR ===== */
        #tab-bar {
            display: flex;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            padding-bottom: max(8px, env(safe-area-inset-bottom));
        }

        .tab-button {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 11px;
            padding: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .tab-button svg {
            width: 22px;
            height: 22px;
        }

        .tab-button.active {
            color: var(--accent);
        }

        /* Icon button styling */
        #settings-toggle svg,
        #bedtime-toggle svg,
        #settings-close svg {
            display: block;
        }
    </style>
</head>
<body>
    <!-- SETTINGS TOGGLE -->
    <button id="settings-toggle" title="Settings">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </button>

    <!-- BEDTIME TOGGLE -->
    <button id="bedtime-toggle" title="Toggle bedtime mode">
        <svg class="icon-moon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
        <svg class="icon-sun" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
    </button>

    <!-- SETTINGS PANEL -->
    <div id="settings-panel">
        <button id="settings-close">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <div id="settings-title">settings</div>

        <div class="settings-section">
            <div class="settings-section-title">Notifications</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Bedtime reminder<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Prompt to capture thoughts before sleep</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-bedtime-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Morning focus<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Daily reminder of your focus items</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-morning-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Periodic reminders<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Gentle nudges throughout the day</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-periodic-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Display</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Daily focus items</div>
                    <div class="settings-item-desc">How many tasks to show each day</div>
                </div>
                <select id="setting-daily-items" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="5">5</option>
                </select>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Bedtime Mode</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Starts at</div>
                    <div class="settings-item-desc">When bedtime mode activates</div>
                </div>
                <select id="setting-bedtime-start" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="20">8 pm</option>
                    <option value="21" selected>9 pm</option>
                    <option value="22">10 pm</option>
                    <option value="23">11 pm</option>
                </select>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Ends at</div>
                    <div class="settings-item-desc">When bedtime mode turns off</div>
                </div>
                <select id="setting-bedtime-end" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="5">5 am</option>
                    <option value="6" selected>6 am</option>
                    <option value="7">7 am</option>
                    <option value="8">8 am</option>
                </select>
            </div>
        </div>

    </div>

    <!-- TABS -->
    <div id="tabs-container">
        <div id="tabs-track">
            <!-- CAPTURE TAB -->
            <div id="capture-tab" class="tab-content">
                <div id="mic-container">
                    <div class="ripple ripple-1"></div>
                    <div class="ripple ripple-2"></div>
                    <button id="big-mic-button">tap to capture</button>
                </div>
                <div id="capture-confirmation"></div>
                <div id="text-input-section">
                    <input type="text" id="thought-input" placeholder="or type here">
                </div>
                <div id="capture-swipe-hint">
                    <svg class="hint-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="18 15 12 9 6 15"></polyline>
                    </svg>
                    <span>today's focus</span>
                </div>
            </div>

            <!-- TODAY TAB -->
            <div id="today-tab" class="tab-content">
                <div id="old-items-section" style="display: none;">
                    <div class="section-title">been on your mind</div>
                    <ul id="old-items-list" class="task-list"></ul>
                </div>

                <div class="section-title">for later</div>
                <ul id="later-list" class="task-list"></ul>

                <div class="section-title">done</div>
                <ul id="completed-today-list" class="task-list"></ul>
            </div>

            <!-- ALL TAB -->
            <div id="all-tab" class="tab-content">
                <div class="section-title">backlog</div>
                <div id="backlog-list"></div>
            </div>

            <!-- PATTERNS TAB -->
            <div id="patterns-tab" class="tab-content">
                <div class="section-title">patterns</div>
                <div id="patterns-container"></div>
            </div>
        </div>
    </div>

    <!-- FOCUS OVERLAY -->
    <div id="focus-overlay">
        <div id="focus-handle">
            <div class="handle-pill"></div>
        </div>
        <div id="focus-cards-container">
            <!-- Cards or message will be rendered here -->
        </div>
    </div>

    <!-- TAB BAR -->
    <div id="tab-bar">
        <button class="tab-button active" data-tab="capture-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
            <span>Capture</span>
        </button>
        <button class="tab-button" data-tab="today-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="6"></circle>
                <circle cx="12" cy="12" r="2"></circle>
            </svg>
            <span>Today</span>
        </button>
        <button class="tab-button" data-tab="all-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="8" y1="6" x2="21" y2="6"></line>
                <line x1="8" y1="12" x2="21" y2="12"></line>
                <line x1="8" y1="18" x2="21" y2="18"></line>
                <line x1="3" y1="6" x2="3.01" y2="6"></line>
                <line x1="3" y1="12" x2="3.01" y2="12"></line>
                <line x1="3" y1="18" x2="3.01" y2="18"></line>
            </svg>
            <span>All</span>
        </button>
        <button class="tab-button" data-tab="patterns-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="20" x2="18" y2="10"></line>
                <line x1="12" y1="20" x2="12" y2="4"></line>
                <line x1="6" y1="20" x2="6" y2="14"></line>
            </svg>
            <span>Patterns</span>
        </button>
    </div>

    <script>
        // ===== DATA MODEL =====
        let thoughts = JSON.parse(localStorage.getItem('thoughts')) || [];
        let todayFocus = JSON.parse(localStorage.getItem('todayFocus')) || [];
        let laterToday = JSON.parse(localStorage.getItem('laterToday')) || [];
        let completedToday = JSON.parse(localStorage.getItem('completedToday')) || [];
        let completedAllTime = JSON.parse(localStorage.getItem('completedAllTime')) || [];
        let worries = JSON.parse(localStorage.getItem('worries')) || [];
        let lastResetDate = localStorage.getItem('lastResetDate') || '';

        // Migrate old formats
        thoughts = thoughts.map(item => {
            if (typeof item === 'string') {
                return { text: item, skips: 0, createdAt: Date.now() };
            }
            if (!item.createdAt) {
                item.createdAt = Date.now();
            }
            return item;
        });

        // Migrate completedAllTime from strings to objects
        completedAllTime = completedAllTime.map(item => {
            if (typeof item === 'string') {
                return { text: item, completedAt: Date.now() };
            }
            return item;
        });

        function saveAll() {
            localStorage.setItem('thoughts', JSON.stringify(thoughts));
            localStorage.setItem('todayFocus', JSON.stringify(todayFocus));
            localStorage.setItem('laterToday', JSON.stringify(laterToday));
            localStorage.setItem('completedToday', JSON.stringify(completedToday));
            localStorage.setItem('completedAllTime', JSON.stringify(completedAllTime));
            localStorage.setItem('worries', JSON.stringify(worries));
            localStorage.setItem('lastResetDate', lastResetDate);
        }

        function getTodayDate() {
            return new Date().toDateString();
        }

        function checkDailyReset() {
            const today = getTodayDate();
            if (lastResetDate !== today) {
                // New day - reset
                laterToday = [];
                completedToday = [];
                lastResetDate = today;
                selectTodayFocus();
                saveAll();
            }
        }

        function selectTodayFocus() {
            const count = parseInt(localStorage.getItem('dailyFocusItems') || '3');
            todayFocus = thoughts.slice(0, count).map(t => ({ ...t }));
        }

        // Initialize on load
        checkDailyReset();
        if (todayFocus.length === 0 && thoughts.length > 0) {
            selectTodayFocus();
            saveAll();
        }

        // Track focus overlay state (used by tab swiping)
        let focusVisible = false;

        // ===== SETTINGS =====
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsClose = document.getElementById('settings-close');
        const settingDailyItems = document.getElementById('setting-daily-items');

        settingsToggle.addEventListener('click', () => settingsPanel.classList.add('visible'));
        settingsClose.addEventListener('click', () => settingsPanel.classList.remove('visible'));

        const savedDailyItems = localStorage.getItem('dailyFocusItems') || '3';
        settingDailyItems.value = savedDailyItems;

        settingDailyItems.addEventListener('change', function() {
            localStorage.setItem('dailyFocusItems', this.value);
            selectTodayFocus();
            saveAll();
            renderFocusCards();
        });

        // ===== PATTERNS =====
        function renderPatterns() {
            const container = document.getElementById('patterns-container');
            const now = Date.now();
            const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);
            const twoWeeksAgo = now - (14 * 24 * 60 * 60 * 1000);

            // Calculate stats
            const totalCaptured = thoughts.length + completedAllTime.length + worries.length;
            const totalCompleted = completedAllTime.length;
            const thisWeekCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > oneWeekAgo).length;
            const lastWeekCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > twoWeeksAgo && t.completedAt <= oneWeekAgo).length;
            const backlogSize = thoughts.length;
            const worriesReleased = worries.length;

            // Not enough data
            if (totalCaptured < 3) {
                container.innerHTML = '<div class="empty-section">capture a few more thoughts to see patterns</div>';
                return;
            }

            let html = '';

            // Top row: key numbers
            html += '<div class="pattern-row">';
            html += `<div class="pattern-card">
                <div class="pattern-card-label">completed</div>
                <div class="pattern-card-value">${totalCompleted}</div>
                <div class="pattern-card-detail">all time</div>
            </div>`;
            html += `<div class="pattern-card">
                <div class="pattern-card-label">waiting</div>
                <div class="pattern-card-value">${backlogSize}</div>
                <div class="pattern-card-detail">in backlog</div>
            </div>`;
            html += '</div>';

            // This week vs last week
            if (thisWeekCompleted > 0 || lastWeekCompleted > 0) {
                let velocityDetail = '';
                if (lastWeekCompleted > 0 && thisWeekCompleted > lastWeekCompleted) {
                    velocityDetail = `up from ${lastWeekCompleted} last week`;
                } else if (lastWeekCompleted > 0 && thisWeekCompleted < lastWeekCompleted) {
                    velocityDetail = `down from ${lastWeekCompleted} last week`;
                } else if (lastWeekCompleted > 0) {
                    velocityDetail = `same as last week`;
                } else {
                    velocityDetail = 'this week';
                }
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">this week</div>
                    <div class="pattern-card-value">${thisWeekCompleted}</div>
                    <div class="pattern-card-detail">${velocityDetail}</div>
                </div>`;
            }

            // Day of week activity
            const allTimestamps = [
                ...thoughts.map(t => t.createdAt),
                ...completedAllTime.map(t => t.createdAt || t.completedAt).filter(Boolean),
                ...worries.map(w => w.createdAt)
            ].filter(Boolean);

            if (allTimestamps.length >= 7) {
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayCounts = dayNames.map(() => 0);
                allTimestamps.forEach(ts => {
                    const day = new Date(ts).getDay();
                    dayCounts[day]++;
                });
                const maxCount = Math.max(...dayCounts, 1);

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">activity by day</div>
                    <div class="pattern-bar-container">`;
                dayNames.forEach((name, i) => {
                    const pct = Math.round((dayCounts[i] / maxCount) * 100);
                    html += `<div class="pattern-bar-row">
                        <div class="pattern-bar-label">${name}</div>
                        <div class="pattern-bar-track">
                            <div class="pattern-bar-fill" style="width: ${pct}%"></div>
                        </div>
                    </div>`;
                });
                html += '</div></div>';
            }

            // Oldest item
            const thoughtsWithDates = thoughts.filter(t => t.createdAt);
            if (thoughtsWithDates.length > 0) {
                const oldest = thoughtsWithDates.reduce((a, b) => a.createdAt < b.createdAt ? a : b);
                const daysOld = Math.floor((now - oldest.createdAt) / (1000 * 60 * 60 * 24));
                if (daysOld >= 3) {
                    const truncated = oldest.text.length > 40 ? oldest.text.slice(0, 40) + '...' : oldest.text;
                    const timeStr = daysOld >= 14 ? `${Math.floor(daysOld / 7)} weeks` : `${daysOld} days`;
                    html += `<div class="pattern-card">
                        <div class="pattern-card-label">oldest in backlog</div>
                        <div class="pattern-card-detail" style="font-size: 15px; color: var(--text-color); margin-top: 8px;">"${truncated}"</div>
                        <div class="pattern-card-detail">${timeStr} old</div>
                    </div>`;
                }
            }

            // Frequently deferred
            const frequentlySkipped = thoughts.filter(t => t.skips >= 2).sort((a, b) => b.skips - a.skips);
            if (frequentlySkipped.length > 0) {
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">keeps getting pushed back</div>`;
                frequentlySkipped.slice(0, 3).forEach(item => {
                    const truncated = item.text.length > 35 ? item.text.slice(0, 35) + '...' : item.text;
                    html += `<div class="pattern-card-detail" style="margin-top: 8px;">
                        "${truncated}" <span style="color: var(--text-muted);">Â· ${item.skips}x</span>
                    </div>`;
                });
                html += '</div>';
            }

            // Worries released
            if (worriesReleased > 0) {
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">worries released</div>
                    <div class="pattern-card-value">${worriesReleased}</div>
                    <div class="pattern-card-detail">captured and let go</div>
                </div>`;
            }

            container.innerHTML = html;
        }

        // ===== TAB SWITCHING =====
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabsTrack = document.getElementById('tabs-track');
        const tabIds = ['capture-tab', 'today-tab', 'all-tab', 'patterns-tab'];
        let currentTabIndex = 0;

        function switchToTab(index, animate = true) {
            if (index < 0 || index >= tabIds.length) return;
            currentTabIndex = index;

            tabButtons.forEach(b => b.classList.remove('active'));
            tabButtons[index].classList.add('active');

            if (animate) {
                tabsTrack.classList.add('animating');
            }
            tabsTrack.style.transform = `translateX(${-index * 100}vw)`;

            if (animate) {
                setTimeout(() => tabsTrack.classList.remove('animating'), 300);
            }

            if (tabIds[index] === 'today-tab') renderTodayTab();
            if (tabIds[index] === 'all-tab') renderAllTab();
            if (tabIds[index] === 'patterns-tab') renderPatterns();
        }

        tabButtons.forEach((btn, index) => {
            btn.addEventListener('click', function() {
                switchToTab(index);
            });
        });

        // Swipe between tabs
        let tabSwipeStartX = 0;
        let tabSwipeStartY = 0;
        let tabSwiping = false;
        let tabSwipeConfirmed = false;

        const tabsContainer = document.getElementById('tabs-container');

        tabsContainer.addEventListener('touchstart', e => {
            // Don't start tab swipe if focus overlay is open
            if (focusVisible) return;
            tabSwipeStartX = e.touches[0].clientX;
            tabSwipeStartY = e.touches[0].clientY;
            tabSwiping = true;
            tabSwipeConfirmed = false;
            tabsTrack.classList.remove('animating');
        }, { passive: true });

        tabsContainer.addEventListener('touchmove', e => {
            if (!tabSwiping || focusVisible) return;

            const diffX = e.touches[0].clientX - tabSwipeStartX;
            const diffY = e.touches[0].clientY - tabSwipeStartY;

            // Determine if this is a horizontal swipe
            if (!tabSwipeConfirmed) {
                if (Math.abs(diffY) > Math.abs(diffX) + 10) {
                    tabSwiping = false;
                    return;
                }
                if (Math.abs(diffX) > 10) {
                    tabSwipeConfirmed = true;
                }
            }

            if (tabSwipeConfirmed) {
                // Calculate the new position based on swipe
                const baseOffset = -currentTabIndex * window.innerWidth;
                const newOffset = baseOffset + diffX;

                // Limit swiping at edges
                const minOffset = -(tabIds.length - 1) * window.innerWidth;
                const clampedOffset = Math.max(minOffset, Math.min(0, newOffset));

                tabsTrack.style.transform = `translateX(${clampedOffset}px)`;
            }
        }, { passive: true });

        tabsContainer.addEventListener('touchend', e => {
            if (!tabSwiping) return;
            tabSwiping = false;

            if (!tabSwipeConfirmed || focusVisible) {
                return;
            }

            const diffX = e.changedTouches[0].clientX - tabSwipeStartX;
            const containerWidth = tabsContainer.offsetWidth;
            const swipeThreshold = containerWidth * 0.2; // 20% of screen

            let newIndex = currentTabIndex;
            if (diffX < -swipeThreshold && currentTabIndex < tabIds.length - 1) {
                newIndex = currentTabIndex + 1;
            } else if (diffX > swipeThreshold && currentTabIndex > 0) {
                newIndex = currentTabIndex - 1;
            }

            switchToTab(newIndex);
        });

        // ===== BEDTIME MODE =====
        const bedtimeToggle = document.getElementById('bedtime-toggle');
        const iconMoon = bedtimeToggle.querySelector('.icon-moon');
        const iconSun = bedtimeToggle.querySelector('.icon-sun');
        const settingBedtimeStart = document.getElementById('setting-bedtime-start');
        const settingBedtimeEnd = document.getElementById('setting-bedtime-end');
        let isBedtimeMode = false;

        // Load saved bedtime hours
        const savedBedtimeStart = localStorage.getItem('bedtimeStart') || '21';
        const savedBedtimeEnd = localStorage.getItem('bedtimeEnd') || '6';
        settingBedtimeStart.value = savedBedtimeStart;
        settingBedtimeEnd.value = savedBedtimeEnd;

        settingBedtimeStart.addEventListener('change', function() {
            localStorage.setItem('bedtimeStart', this.value);
            localStorage.removeItem('bedtimeManualOverride');
        });

        settingBedtimeEnd.addEventListener('change', function() {
            localStorage.setItem('bedtimeEnd', this.value);
            localStorage.removeItem('bedtimeManualOverride');
        });

        function checkBedtimeTime() {
            const hour = new Date().getHours();
            const start = parseInt(localStorage.getItem('bedtimeStart') || '21');
            const end = parseInt(localStorage.getItem('bedtimeEnd') || '6');
            return hour >= start || hour < end;
        }

        function updateBedtimeIcon(enabled) {
            iconMoon.style.display = enabled ? 'none' : 'block';
            iconSun.style.display = enabled ? 'block' : 'none';
        }

        function setBedtimeMode(enabled) {
            isBedtimeMode = enabled;
            document.body.classList.toggle('bedtime-mode', enabled);
            updateBedtimeIcon(enabled);
            localStorage.setItem('bedtimeManualOverride', 'true');
            localStorage.setItem('bedtimeMode', enabled.toString());
        }

        function initBedtimeMode() {
            const manualOverride = localStorage.getItem('bedtimeManualOverride');
            const savedMode = localStorage.getItem('bedtimeMode');
            isBedtimeMode = (manualOverride === 'true' && savedMode !== null)
                ? savedMode === 'true'
                : checkBedtimeTime();
            if (isBedtimeMode) {
                document.body.classList.add('bedtime-mode');
                updateBedtimeIcon(true);
            }
        }

        bedtimeToggle.addEventListener('click', () => setBedtimeMode(!isBedtimeMode));
        initBedtimeMode();

        // ===== CONFIRMATION MESSAGES =====
        const confirmationMessages = ["Got it.", "Noted.", "Saved.", "Done.", "All yours.", "On the list.", "Won't forget."];
        const bedtimeMessages = ["Captured.", "Got it.", "Noted.", "Set aside.", "For tomorrow."];
        const worryMessages = ["Heard.", "Got it.", "Noted.", "Okay.", "Captured."];

        function getRandomConfirmation(type = 'normal') {
            if (type === 'worry') {
                return worryMessages[Math.floor(Math.random() * worryMessages.length)];
            }
            const messages = isBedtimeMode ? bedtimeMessages : confirmationMessages;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        // ===== DETECTION =====
        function isWorry(text) {
            const lower = text.toLowerCase();
            const worryPatterns = [
                /^what if\b/,
                /\bworried\b/,
                /\bworry\b/,
                /\banxious\b/,
                /\bscared\b/,
                /\bafraid\b/,
                /\bnervous\b/,
                /\bstressed\b/,
                /\boverwhelmed\b/,
                /\bcan't stop thinking\b/,
                /\bkeep thinking\b/,
                /\bwhat if .+\?$/,
                /^i('m| am) (so )?(worried|scared|afraid|anxious|nervous)/,
            ];
            return worryPatterns.some(pattern => pattern.test(lower));
        }

        function isVague(text) {
            const lower = text.toLowerCase();
            const vaguePatterns = [
                /^(figure out|deal with|handle|look into|sort out|work on|think about|address)\b/,
                /\b(figure out|deal with|handle|look into|sort out|work on|think about|address) .+$/,
                /^(do|fix|finish) (the |my |that )?(thing|stuff)\b/,
            ];
            return vaguePatterns.some(pattern => pattern.test(lower));
        }

        // ===== CAPTURE =====
        const input = document.getElementById('thought-input');
        const bigMicButton = document.getElementById('big-mic-button');
        const micContainer = document.getElementById('mic-container');
        const confirmation = document.getElementById('capture-confirmation');

        function haptic(style) {
            if ('vibrate' in navigator) {
                navigator.vibrate(style === 'light' ? 10 : style === 'medium' ? 20 : 30);
            }
        }

        function showConfirmation(message) {
            confirmation.textContent = message || getRandomConfirmation();
            confirmation.classList.add('visible');
            bigMicButton.classList.add('captured');
            setTimeout(() => {
                confirmation.classList.remove('visible');
                bigMicButton.classList.remove('captured');
            }, 2000);
        }

        function captureThought(text) {
            const thought = (text || input.value).trim();
            if (thought === '') return;
            input.value = '';

            // Check if this is a worry (not an actionable task)
            if (isWorry(thought)) {
                worries.push({
                    text: thought,
                    createdAt: Date.now()
                });
                saveAll();
                showConfirmation(getRandomConfirmation('worry'));
                haptic('light');
                return;
            }

            // It's a task - check if vague
            const vague = isVague(thought);
            thoughts.push({
                text: thought,
                skips: 0,
                createdAt: Date.now(),
                isVague: vague
            });

            // If today's focus isn't full, add to it
            const maxFocus = parseInt(localStorage.getItem('dailyFocusItems') || '3');
            if (todayFocus.length < maxFocus) {
                todayFocus.push({ text: thought, skips: 0, createdAt: Date.now(), isVague: vague });
            }

            saveAll();
            showConfirmation();
            haptic('medium');
        }

        input.addEventListener('keydown', e => {
            if (e.key === 'Enter') captureThought();
        });

        // Voice capture
        let recognition = null;
        let isListening = false;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = function(e) {
                recognition.stop();
                captureThought(e.results[0][0].transcript);
            };

            recognition.onend = function() {
                isListening = false;
                bigMicButton.classList.remove('listening');
                micContainer.classList.remove('listening');
                bigMicButton.textContent = 'tap to capture';
            };

            recognition.onerror = function(e) {
                console.log('Speech recognition error:', e.error, e);
                isListening = false;
                bigMicButton.classList.remove('listening');
                micContainer.classList.remove('listening');

                if (e.error === 'not-allowed' || e.error === 'service-not-allowed') {
                    bigMicButton.textContent = 'mic blocked';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else if (e.error === 'no-speech') {
                    bigMicButton.textContent = 'no speech heard';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else if (e.error === 'network') {
                    bigMicButton.textContent = 'needs internet';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else if (e.error === 'audio-capture') {
                    bigMicButton.textContent = 'mic unavailable';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else {
                    // Show actual error for debugging
                    bigMicButton.textContent = e.error || 'error';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                }
            };

            async function startListening() {
                // Request mic permission explicitly first (helps with iOS PWA)
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop()); // Release immediately
                } catch (err) {
                    console.log('Mic permission error:', err);
                    bigMicButton.textContent = 'mic blocked';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                    return;
                }

                try {
                    recognition.start();
                    isListening = true;
                    bigMicButton.classList.add('listening');
                    micContainer.classList.add('listening');
                    bigMicButton.textContent = 'listening...';
                } catch (err) {
                    console.log('Speech start error:', err);
                    bigMicButton.textContent = 'use text below';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                }
            }

            bigMicButton.addEventListener('click', function() {
                if (isListening) {
                    recognition.stop();
                } else {
                    startListening();
                }
            });
        } else {
            bigMicButton.disabled = true;
            bigMicButton.textContent = 'voice not supported';
        }

        // ===== FOCUS OVERLAY =====
        const focusOverlay = document.getElementById('focus-overlay');
        const focusHandle = document.getElementById('focus-handle');
        const focusContainer = document.getElementById('focus-cards-container');
        const captureTab = document.getElementById('capture-tab');
        let currentCardIndex = 0;

        function openFocusOverlay() {
            focusVisible = true;
            focusOverlay.classList.add('animating');
            focusOverlay.classList.add('visible');
            focusOverlay.style.transform = '';
            renderFocusCards();
            setTimeout(() => focusOverlay.classList.remove('animating'), 300);
        }

        function closeFocusOverlay() {
            focusVisible = false;
            focusOverlay.classList.add('animating');
            focusOverlay.classList.remove('visible');
            focusOverlay.style.transform = '';
            setTimeout(() => focusOverlay.classList.remove('animating'), 300);
        }

        function renderFocusCards() {
            focusContainer.innerHTML = '';

            // Filter out items already handled today
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));

            if (thoughts.length === 0) {
                focusContainer.innerHTML = `
                    <div id="focus-message">
                        <div id="focus-message-title">nothing here yet</div>
                        <div id="focus-message-subtitle">swipe down to add something</div>
                    </div>`;
                return;
            }

            if (remaining.length === 0) {
                const allDone = todayFocus.length > 0 && completedToday.length === todayFocus.length;
                focusContainer.innerHTML = `
                    <div id="focus-message">
                        <div id="focus-message-title">${allDone ? 'all done' : 'all set'}</div>
                        <div id="focus-message-subtitle">${allDone ? "that's everything" : 'see you tomorrow'}</div>
                    </div>`;
                return;
            }

            // Show all remaining cards
            remaining.forEach((item, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'focus-card-wrapper';
                wrapper.innerHTML = `
                    <div class="swipe-bg swipe-bg-left">later</div>
                    <div class="swipe-bg swipe-bg-right">done</div>
                    <div class="focus-card">
                        <div class="focus-card-text">${item.text}</div>
                    </div>
                `;
                setupCardSwipe(wrapper, item);
                focusContainer.appendChild(wrapper);
            });
        }

        function setupCardSwipe(wrapper, item) {
            const card = wrapper.querySelector('.focus-card');
            const bgLeft = wrapper.querySelector('.swipe-bg-left');
            const bgRight = wrapper.querySelector('.swipe-bg-right');
            let startX = 0, currentX = 0, swiping = false;

            card.addEventListener('touchstart', e => {
                startX = e.touches[0].clientX;
                currentX = startX;
                swiping = true;
                card.classList.add('swiping');
            }, { passive: true });

            card.addEventListener('touchmove', e => {
                if (!swiping) return;
                currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                card.style.transform = `translateX(${diff}px)`;

                const threshold = 80;
                if (diff > 0) {
                    bgRight.style.opacity = Math.min(1, diff / threshold);
                    bgLeft.style.opacity = 0;
                } else if (diff < 0) {
                    bgLeft.style.opacity = Math.min(1, -diff / threshold);
                    bgRight.style.opacity = 0;
                } else {
                    bgLeft.style.opacity = 0;
                    bgRight.style.opacity = 0;
                }
            }, { passive: true });

            card.addEventListener('touchend', e => {
                if (!swiping) return;
                swiping = false;
                card.classList.remove('swiping');

                const diff = currentX - startX;

                if (diff > 80) {
                    // Swipe right - done
                    card.style.transform = 'translateX(100vw)';
                    haptic('medium');
                    setTimeout(() => {
                        wrapper.classList.add('removing');
                        setTimeout(() => {
                            completedToday.push(item);
                            thoughts = thoughts.filter(t => t.text !== item.text);
                            completedAllTime.push({
                                text: item.text,
                                completedAt: Date.now(),
                                createdAt: item.createdAt
                            });
                            saveAll();
                            renderFocusCards();
                        }, 300);
                    }, 200);
                } else if (diff < -80) {
                    // Swipe left - later
                    card.style.transform = 'translateX(-100vw)';
                    haptic('light');
                    setTimeout(() => {
                        wrapper.classList.add('removing');
                        setTimeout(() => {
                            laterToday.push(item);
                            const idx = thoughts.findIndex(t => t.text === item.text);
                            if (idx > -1) {
                                const t = thoughts.splice(idx, 1)[0];
                                t.skips = (t.skips || 0) + 1;
                                thoughts.push(t);
                            }
                            saveAll();
                            renderFocusCards();
                        }, 300);
                    }, 200);
                } else {
                    // Snap back
                    card.style.transform = '';
                    bgLeft.style.opacity = 0;
                    bgRight.style.opacity = 0;
                }
            });
        }

        // Swipe up on capture tab to open focus overlay
        let captureStartY = 0, captureDragging = false;

        captureTab.addEventListener('touchstart', e => {
            if (focusVisible) return;
            const touch = e.touches[0];
            // Only trigger from bottom half
            if (touch.clientY > window.innerHeight * 0.5) {
                captureStartY = touch.clientY;
                captureDragging = true;
            }
        }, { passive: true });

        captureTab.addEventListener('touchmove', e => {
            if (!captureDragging || focusVisible) return;
            const diff = captureStartY - e.touches[0].clientY;
            if (diff > 10) {
                const progress = Math.min(diff / (window.innerHeight * 0.5), 1);
                focusOverlay.style.transform = `translateY(${(1 - progress) * 100}%)`;
            }
        }, { passive: true });

        captureTab.addEventListener('touchend', e => {
            if (!captureDragging) return;
            captureDragging = false;
            const diff = captureStartY - e.changedTouches[0].clientY;
            if (diff > 100) {
                openFocusOverlay();
            } else {
                focusOverlay.style.transform = '';
            }
        });

        // Swipe down anywhere on focus overlay to close
        let overlayStartY = 0, overlayStartX = 0, overlayDragging = false, overlayDragConfirmed = false;

        focusOverlay.addEventListener('touchstart', e => {
            overlayStartY = e.touches[0].clientY;
            overlayStartX = e.touches[0].clientX;
            overlayDragging = true;
            overlayDragConfirmed = false;
        }, { passive: true });

        focusOverlay.addEventListener('touchmove', e => {
            if (!overlayDragging) return;

            const diffY = e.touches[0].clientY - overlayStartY;
            const diffX = e.touches[0].clientX - overlayStartX;

            // Only handle if vertical swipe is dominant and downward
            if (!overlayDragConfirmed) {
                if (Math.abs(diffX) > 20) {
                    // Horizontal swipe - let card handle it
                    overlayDragging = false;
                    return;
                }
                if (diffY > 20) {
                    overlayDragConfirmed = true;
                }
            }

            if (overlayDragConfirmed && diffY > 0) {
                focusOverlay.style.transform = `translateY(${diffY}px)`;
            }
        }, { passive: true });

        focusOverlay.addEventListener('touchend', e => {
            if (!overlayDragging) return;
            overlayDragging = false;

            if (!overlayDragConfirmed) {
                return;
            }

            const diff = e.changedTouches[0].clientY - overlayStartY;
            if (diff > 100) {
                closeFocusOverlay();
            } else {
                focusOverlay.classList.add('animating');
                focusOverlay.style.transform = '';
                setTimeout(() => focusOverlay.classList.remove('animating'), 300);
            }
        });

        // ===== TODAY TAB =====
        const laterList = document.getElementById('later-list');
        const completedTodayList = document.getElementById('completed-today-list');
        const oldItemsSection = document.getElementById('old-items-section');
        const oldItemsList = document.getElementById('old-items-list');

        function getTimeAgo(timestamp) {
            const days = Math.floor((Date.now() - timestamp) / (1000 * 60 * 60 * 24));
            if (days < 7) return `${days} day${days !== 1 ? 's' : ''} ago`;
            const weeks = Math.floor(days / 7);
            return `${weeks} week${weeks !== 1 ? 's' : ''} ago`;
        }

        function addToTodayFocus(item) {
            // Add to today's focus if not already there
            if (!todayFocus.find(t => t.text === item.text)) {
                todayFocus.push({ ...item });
                saveAll();
                renderTodayTab();
                renderFocusCards();
                haptic('light');
            }
        }

        function renderTodayTab() {
            // Old items (2+ weeks old, not in today's focus)
            const twoWeeksAgo = Date.now() - (14 * 24 * 60 * 60 * 1000);
            const focusTexts = todayFocus.map(t => t.text);
            const oldItems = thoughts
                .filter(t => t.createdAt && t.createdAt < twoWeeksAgo && !focusTexts.includes(t.text))
                .slice(0, 2);

            if (oldItems.length > 0) {
                oldItemsSection.style.display = 'block';
                oldItemsList.innerHTML = '';
                oldItems.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'task-item old tappable';
                    li.innerHTML = `
                        ${item.text}
                        <div class="task-item-age">${getTimeAgo(item.createdAt)} Â· tap to focus</div>
                    `;
                    li.addEventListener('click', () => addToTodayFocus(item));
                    oldItemsList.appendChild(li);
                });
            } else {
                oldItemsSection.style.display = 'none';
            }

            // For later
            laterList.innerHTML = laterToday.length === 0
                ? '<li class="empty-section">nothing pushed back</li>'
                : laterToday.map(item => `<li class="task-item later">${item.text}</li>`).join('');

            // Completed
            completedTodayList.innerHTML = completedToday.length === 0
                ? '<li class="empty-section">â</li>'
                : completedToday.map(item => `<li class="task-item completed">${item.text}</li>`).join('');
        }

        // ===== ALL TAB =====
        const backlogList = document.getElementById('backlog-list');
        let draggedItem = null;
        let draggedIndex = -1;
        let placeholder = null;

        function renderAllTab() {
            // Show thoughts not in today's focus
            const focusTexts = todayFocus.map(t => t.text);
            const backlog = thoughts.filter(t => !focusTexts.includes(t.text));

            if (backlog.length === 0) {
                backlogList.innerHTML = '<div class="empty-section">nothing waiting</div>';
                return;
            }

            backlogList.innerHTML = '';
            backlog.forEach((item, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'backlog-item-wrapper';
                wrapper.dataset.index = index;
                wrapper.innerHTML = `
                    <div class="backlog-swipe-bg backlog-swipe-delete">delete</div>
                    <div class="backlog-item">
                        <div class="backlog-item-text">${item.text}</div>
                        ${item.skips > 0 ? `<div class="backlog-item-meta">skipped ${item.skips}x</div>` : ''}
                    </div>
                `;
                setupBacklogInteraction(wrapper, item, index, backlog);
                backlogList.appendChild(wrapper);
            });
        }

        function setupBacklogInteraction(wrapper, item, originalIndex, backlog) {
            const itemEl = wrapper.querySelector('.backlog-item');
            const deleteBg = wrapper.querySelector('.backlog-swipe-delete');

            let startX = 0, startY = 0, currentX = 0, currentY = 0;
            let swiping = false, dragging = false, pendingDelete = false;
            let longPressTimer = null;
            let wrapperRect = null;
            let allWrappers = [];
            const LONG_PRESS_DURATION = 400;

            function confirmDelete() {
                itemEl.style.transform = 'translateX(-100vw)';
                haptic('medium');
                setTimeout(() => {
                    wrapper.classList.add('removing');
                    setTimeout(() => {
                        thoughts = thoughts.filter(t => t.text !== item.text);
                        todayFocus = todayFocus.filter(t => t.text !== item.text);
                        saveAll();
                        renderAllTab();
                        renderFocusCards();
                    }, 300);
                }, 150);
            }

            function cancelPendingDelete() {
                pendingDelete = false;
                deleteBg.classList.remove('confirm');
                deleteBg.textContent = 'delete';
                itemEl.style.transform = '';
                deleteBg.style.opacity = 0;
            }

            // Tap on delete background to confirm
            deleteBg.addEventListener('click', e => {
                if (pendingDelete) {
                    e.stopPropagation();
                    confirmDelete();
                }
            });

            function startDragMode(e) {
                dragging = true;
                swiping = false;
                draggedItem = item;
                draggedIndex = originalIndex;

                wrapperRect = wrapper.getBoundingClientRect();
                allWrappers = Array.from(backlogList.querySelectorAll('.backlog-item-wrapper'));

                // Create placeholder
                placeholder = document.createElement('div');
                placeholder.className = 'backlog-placeholder';
                placeholder.style.height = wrapperRect.height + 'px';

                // Style dragged item
                wrapper.classList.add('dragging');
                wrapper.style.position = 'fixed';
                wrapper.style.left = wrapperRect.left + 'px';
                wrapper.style.top = wrapperRect.top + 'px';
                wrapper.style.width = wrapperRect.width + 'px';
                wrapper.style.zIndex = '100';

                // Insert placeholder
                wrapper.parentNode.insertBefore(placeholder, wrapper);
                document.body.appendChild(wrapper);

                haptic('medium');
            }

            itemEl.addEventListener('touchstart', e => {
                // Cancel any pending delete when starting new interaction
                if (pendingDelete) {
                    cancelPendingDelete();
                }

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                currentX = startX;
                currentY = startY;
                swiping = true;
                itemEl.classList.add('swiping');

                // Start long press timer
                longPressTimer = setTimeout(() => {
                    if (swiping && Math.abs(currentX - startX) < 10 && Math.abs(currentY - startY) < 10) {
                        startDragMode(e);
                    }
                }, LONG_PRESS_DURATION);
            }, { passive: true });

            itemEl.addEventListener('touchmove', e => {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;

                // If moved too much, cancel long press
                if (longPressTimer && (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startY) > 10)) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (dragging) {
                    // Drag mode - move vertically
                    const diff = currentY - startY;
                    wrapper.style.top = (wrapperRect.top + diff) + 'px';

                    // Find where to insert placeholder
                    const wrapperCenterY = wrapperRect.top + diff + wrapperRect.height / 2;
                    let insertBefore = null;

                    allWrappers.forEach(w => {
                        if (w === wrapper) return;
                        const rect = w.getBoundingClientRect();
                        if (wrapperCenterY < rect.top + rect.height / 2) {
                            if (!insertBefore || rect.top < insertBefore.getBoundingClientRect().top) {
                                insertBefore = w;
                            }
                        }
                    });

                    // Move placeholder
                    if (insertBefore) {
                        backlogList.insertBefore(placeholder, insertBefore);
                    } else {
                        backlogList.appendChild(placeholder);
                    }
                } else if (swiping) {
                    // Swipe mode - move horizontally (left only)
                    const diffX = currentX - startX;
                    if (diffX < 0) {
                        itemEl.style.transform = `translateX(${diffX}px)`;
                        const opacity = Math.min(1, (-diffX - 30) / 50);
                        deleteBg.style.opacity = Math.max(0, opacity);
                    }
                }
            }, { passive: true });

            itemEl.addEventListener('touchend', e => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (dragging) {
                    // End drag mode
                    dragging = false;

                    // Get new position based on placeholder
                    const newIndex = Array.from(backlogList.children).indexOf(placeholder);

                    // Reset wrapper styling
                    wrapper.classList.remove('dragging');
                    wrapper.style.position = '';
                    wrapper.style.left = '';
                    wrapper.style.top = '';
                    wrapper.style.width = '';
                    wrapper.style.zIndex = '';

                    // Insert at new position
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.insertBefore(wrapper, placeholder);
                        placeholder.remove();
                    }
                    placeholder = null;

                    // Update thoughts array
                    if (newIndex !== -1 && newIndex !== originalIndex) {
                        const focusTexts = todayFocus.map(t => t.text);
                        const backlogItems = thoughts.filter(t => !focusTexts.includes(t.text));
                        const movedItem = backlogItems[originalIndex];

                        // Remove from original position in thoughts
                        const thoughtsIndex = thoughts.findIndex(t => t.text === movedItem.text);
                        if (thoughtsIndex > -1) {
                            thoughts.splice(thoughtsIndex, 1);
                        }

                        // Find insert position in thoughts (after focus items)
                        const focusCount = thoughts.filter(t => focusTexts.includes(t.text)).length;
                        const insertAt = focusCount + newIndex;
                        thoughts.splice(insertAt, 0, movedItem);

                        saveAll();
                        haptic('light');
                    }

                    draggedItem = null;
                    draggedIndex = -1;
                } else if (swiping) {
                    // End swipe mode
                    swiping = false;
                    itemEl.classList.remove('swiping');

                    const diffX = currentX - startX;
                    const diffY = currentY - startY;

                    if (diffX < -100) {
                        // Show delete confirmation
                        pendingDelete = true;
                        const itemWidth = itemEl.offsetWidth;
                        itemEl.style.transform = `translateX(-${itemWidth}px)`;
                        deleteBg.style.opacity = 1;
                        deleteBg.classList.add('confirm');
                        deleteBg.textContent = 'tap to delete';
                        haptic('light');
                    } else if (Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
                        // Simple tap - add to today's focus
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                        addToTodayFocus(item);
                    } else {
                        // Snap back
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                    }
                }
            });

            // Handle touch cancel
            itemEl.addEventListener('touchcancel', () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                swiping = false;
                dragging = false;
                if (pendingDelete) cancelPendingDelete();
                itemEl.classList.remove('swiping');
                wrapper.classList.remove('dragging');
                itemEl.style.transform = '';
                deleteBg.style.opacity = 0;
            });
        }

        // ===== SERVICE WORKER =====
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('Service Worker registration failed:', err));
        }

        // Check for daily reset periodically
        setInterval(checkDailyReset, 60000);
    </script>
</body>
</html>
