<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Daily Overwhelm</title>

    <!-- PWA setup -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Overwhelm">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        * {
            box-sizing: border-box;
        }

        :root {
            --bg-color: #12121f;
            --card-bg: #1e2140;
            --text-color: #eee;
            --text-muted: #999;
            --text-light: #bbb;
            --border-color: #2a2d4a;
            --input-bg: #0f0f1a;
            --accent: #4a90a4;
            --done-color: #5cb85c;
            --later-color: #f0ad4e;
        }

        /* Bedtime mode - warmer, softer colors */
        body.bedtime-mode {
            --bg-color: #141210;
            --card-bg: #2a2520;
            --text-color: #e8dcc8;
            --text-muted: #a09080;
            --text-light: #c8b8a0;
            --border-color: #3a3530;
            --input-bg: #141210;
            --accent: #c4956a;
        }

        body.bedtime-mode #big-mic-button {
            box-shadow: 0 4px 20px rgba(196, 149, 106, 0.3);
        }

        body.bedtime-mode .ripple {
            border-color: var(--accent);
        }

        /* Top buttons row - appears at top of each tab */
        .tab-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        /* Capture tab needs absolute positioning for the icons since it uses flexbox centering */
        #capture-tab .tab-top-row {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            margin-bottom: 0;
        }

        /* Remove top margin from first content after icons - needs specificity to override .section-title */
        .tab-top-row + .section-title,
        #today-tab > #old-items-section + .section-title {
            margin-top: 0;
        }

        .tab-top-btn {
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
            padding: 8px;
        }

        .tab-top-btn:active {
            opacity: 1;
        }

        .tab-top-btn:hover {
            opacity: 1;
        }

        /* Settings panel */
        #settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-color);
            z-index: 200;
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            padding: 20px;
            padding-top: 60px;
        }

        #settings-panel.visible {
            transform: translateX(0);
        }

        #settings-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
        }

        #settings-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 30px;
            color: var(--text-color);
        }

        .settings-section {
            margin-bottom: 30px;
        }

        .settings-section-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 15px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-item-label {
            font-size: 16px;
            color: var(--text-color);
        }

        .settings-item-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .toggle-switch input:disabled + .toggle-slider {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-coming-soon {
            font-size: 11px;
            color: var(--accent);
            margin-left: 10px;
        }

        /* Dev tools */
        .dev-tools-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .dev-tools-warning {
            font-size: 12px;
            color: var(--later-color);
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(240, 173, 78, 0.1);
            border-radius: 8px;
        }

        .dev-button {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 8px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.15s;
        }

        .dev-button:active {
            background-color: var(--border-color);
        }

        .dev-button.danger {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .dev-button-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .dev-subsection {
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--text-muted);
        }

        /* Hide text input in bedtime mode */
        body.bedtime-mode #text-input-section {
            display: none;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* Tab content */
        #tabs-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;
        }

        #tabs-track {
            display: flex;
            height: 100%;
            will-change: transform;
        }

        #tabs-track.animating {
            transition: transform 0.3s ease-out;
        }

        .tab-content {
            flex: none;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            width: 100vw;
            min-width: 100vw;
        }

        /* Disable scrolling during tab swipe */
        #tabs-container.tab-swiping .tab-content {
            overflow-y: hidden;
        }

        /* ===== CAPTURE TAB ===== */
        #capture-tab {
            position: relative;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #mic-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #big-mic-button {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background-color: var(--accent);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 4px 20px rgba(74, 144, 164, 0.4);
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
            position: relative;
            z-index: 2;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 0.5px;
            text-transform: lowercase;
        }

        #big-mic-button:active {
            transform: scale(0.98);
        }

        #big-mic-button.listening {
            background-color: #e74c3c;
            box-shadow: 0 4px 30px rgba(231, 76, 60, 0.5);
            animation: pulse-listening 1s infinite;
        }

        .ripple {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 1px solid var(--accent);
            opacity: 0;
            z-index: 1;
            pointer-events: none;
        }

        .ripple-1 { animation: ripple 7s ease-out infinite; }
        .ripple-2 { animation: ripple 7s ease-out infinite 2s; }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 0.4; }
            57% { transform: scale(1.8); opacity: 0; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        @keyframes pulse-listening {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #mic-container.listening .ripple {
            animation: none;
            opacity: 0;
        }

        #capture-confirmation {
            margin-top: 30px;
            padding: 12px 24px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 20px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: 0.3px;
            opacity: 0;
            transform: scale(0.9) translateY(10px);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        #capture-confirmation.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        /* Capture success flash on button */
        #big-mic-button.captured {
            animation: capture-flash 0.4s ease-out;
        }

        @keyframes capture-flash {
            0% { transform: scale(1); }
            30% { transform: scale(0.95); }
            60% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        #text-input-section {
            position: absolute;
            bottom: 80px;
            left: 20px;
            right: 20px;
            max-width: 300px;
            margin: 0 auto;
        }

        #thought-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-color);
            text-align: center;
        }

        #thought-input::placeholder {
            color: var(--text-muted);
        }

        /* Morning intention banner */
        #morning-banner {
            position: absolute;
            top: 60px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a2a4a 0%, #1e3a5a 100%);
            border-radius: 16px;
            padding: 18px 20px;
            border: 1px solid rgba(74, 144, 164, 0.4);
            display: none;
            flex-direction: column;
            gap: 12px;
            animation: morningFadeIn 0.4s ease-out;
            z-index: 10;
        }

        #morning-banner.visible {
            display: flex;
        }

        @keyframes morningFadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .morning-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .morning-greeting {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
        }

        .morning-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .morning-prompt {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .morning-focus-preview {
            font-size: 15px;
            color: var(--text-light);
            padding: 10px 12px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .morning-action {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .morning-action:active {
            opacity: 0.8;
        }

        /* Weekly reflection banner */
        #weekly-banner {
            position: absolute;
            top: 60px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a2a2a 0%, #1e3a30 100%);
            border-radius: 16px;
            padding: 18px 20px;
            border: 1px solid rgba(92, 184, 92, 0.4);
            display: none;
            flex-direction: column;
            gap: 12px;
            animation: morningFadeIn 0.4s ease-out;
            z-index: 10;
        }

        #weekly-banner.visible {
            display: flex;
        }

        .weekly-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .weekly-greeting {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
        }

        .weekly-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .weekly-stats {
            display: flex;
            gap: 16px;
        }

        .weekly-stat {
            flex: 1;
            text-align: center;
            padding: 12px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .weekly-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-color);
        }

        .weekly-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        .weekly-action {
            background-color: var(--done-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .weekly-action:active {
            opacity: 0.8;
        }

        /* Past reflections in patterns tab */
        .reflection-card {
            background-color: var(--card-bg);
            border-radius: 14px;
            padding: 16px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(92, 184, 92, 0.06) 100%);
        }

        .reflection-week {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .reflection-stats {
            display: flex;
            gap: 20px;
        }

        .reflection-stat {
            font-size: 14px;
            color: var(--text-color);
        }

        .reflection-stat span {
            font-weight: 600;
        }

        /* Swipe hint at bottom of capture tab */
        #capture-swipe-hint {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: var(--text-muted);
            opacity: 0.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        #capture-swipe-hint .hint-chevron {
            width: 20px;
            height: 20px;
            opacity: 0.5;
            animation: hint-bounce 2s ease-in-out infinite;
        }

        @keyframes hint-bounce {
            0%, 100% { transform: translateY(0); opacity: 0.5; }
            50% { transform: translateY(-4px); opacity: 0.8; }
        }

        /* ===== FOCUS OVERLAY (swipe up from capture) ===== */
        #focus-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-color);
            z-index: 100;
            transform: translateY(100%);
            display: flex;
            flex-direction: column;
            will-change: transform;
        }

        #focus-overlay.animating {
            transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
        }

        #focus-overlay.visible {
            transform: translateY(0);
        }

        #focus-handle {
            padding: 15px;
            display: flex;
            justify-content: center;
            cursor: grab;
        }

        #focus-handle:active {
            cursor: grabbing;
        }

        .handle-pill {
            width: 36px;
            height: 4px;
            background-color: var(--text-muted);
            border-radius: 2px;
            opacity: 0.4;
        }

        #focus-cards-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 30px;
            gap: 14px;
            overflow: hidden;
        }

        #focus-message {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 20px;
        }

        #focus-message-title {
            font-size: 22px;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 8px;
        }

        #focus-message-subtitle {
            font-size: 15px;
            color: var(--text-muted);
        }

        /* Focus card wrapper */
        .focus-card-wrapper {
            position: relative;
            flex: 1;
            max-height: 140px;
            min-height: 80px;
            border-radius: 12px;
            overflow: hidden;
            transition: flex 0.3s ease-out, opacity 0.3s ease-out, max-height 0.3s ease-out;
        }

        .focus-card-wrapper.removing {
            flex: 0;
            max-height: 0;
            opacity: 0;
            margin: 0;
        }

        /* Swipe backgrounds */
        .swipe-bg {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: lowercase;
            color: white;
            opacity: 0;
            transition: opacity 0.15s;
            border-radius: 12px;
        }

        .swipe-bg-left {
            background: linear-gradient(135deg, var(--later-color), #e09530);
            justify-content: flex-end;
        }

        .swipe-bg-right {
            background: linear-gradient(135deg, #4caf50, var(--done-color));
            justify-content: flex-start;
        }

        /* Focus card */
        .focus-card {
            position: relative;
            height: 100%;
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 18px 20px;
            display: flex;
            align-items: center;
            touch-action: pan-y pinch-zoom;
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .focus-card:active {
            box-shadow: 0 6px 24px rgba(0,0,0,0.2);
        }

        .focus-card.swiping {
            transition: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25);
        }

        .focus-card-text {
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.5;
            flex: 1;
            font-weight: 500;
            position: relative;
            z-index: 1;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .focus-progress {
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 11px;
            color: var(--text-muted);
            opacity: 0.7;
        }

        /* ===== TODAY TAB ===== */
        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.2px;
            margin-bottom: 12px;
            margin-top: 28px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item {
            padding: 16px 18px;
            background-color: var(--card-bg);
            border-radius: 12px;
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-color);
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .task-item.tappable {
            cursor: pointer;
        }

        .task-item.tappable:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .task-item.later {
            border-left: 3px solid var(--later-color);
        }

        .task-item.completed {
            border-left: 3px solid var(--done-color);
            color: var(--text-light);
        }

        .task-item.old {
            border-left: 3px solid var(--text-muted);
            opacity: 0.9;
        }

        .task-item-age {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .empty-section {
            color: var(--text-muted);
            font-size: 14px;
            padding: 20px;
            text-align: center;
            opacity: 0.6;
        }

        /* ===== PATTERNS TAB ===== */
        .pattern-section {
            margin-bottom: 28px;
        }

        .pattern-section-header {
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .pattern-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .pattern-card {
            background-color: var(--card-bg);
            border-radius: 14px;
            padding: 18px;
            margin-bottom: 12px;
            border: 1px solid rgba(255,255,255,0.03);
        }

        .pattern-card.highlight {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(74, 144, 164, 0.12) 100%);
        }

        .pattern-card.highlight-green {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(92, 184, 92, 0.1) 100%);
        }

        .pattern-card-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 8px;
        }

        .pattern-card-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-color);
            line-height: 1;
        }

        .pattern-card-value.small {
            font-size: 24px;
        }

        .pattern-card-detail {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .pattern-row {
            display: flex;
            gap: 12px;
        }

        .pattern-row .pattern-card {
            flex: 1;
        }

        .pattern-row-3 {
            display: flex;
            gap: 10px;
        }

        .pattern-row-3 .pattern-card {
            flex: 1;
            padding: 14px;
        }

        .pattern-row-3 .pattern-card-value {
            font-size: 26px;
        }

        /* Interactive bar charts */
        .pattern-bar-container {
            margin-top: 14px;
        }

        .pattern-bar-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 4px 0;
            border-radius: 6px;
            transition: background-color 0.15s;
        }

        .pattern-bar-row:active {
            background-color: rgba(255,255,255,0.05);
        }

        .pattern-bar-row.selected {
            background-color: rgba(74, 144, 164, 0.15);
        }

        .pattern-bar-label {
            width: 36px;
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .pattern-bar-track {
            flex: 1;
            height: 8px;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .pattern-bar-row.selected .pattern-bar-track {
            height: 10px;
        }

        .pattern-bar-value {
            min-width: 28px;
            text-align: right;
            font-size: 11px;
            color: var(--text-muted);
            margin-left: 10px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .pattern-bar-row.selected .pattern-bar-value,
        .pattern-bar-container.show-values .pattern-bar-value {
            opacity: 1;
        }

        .pattern-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #6bb3c9);
            border-radius: 3px;
            transition: width 0.4s ease-out;
        }

        .pattern-quote {
            font-size: 14px;
            color: var(--text-light);
            line-height: 1.5;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .pattern-quote:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .pattern-quote-skip {
            color: var(--text-muted);
            font-size: 12px;
            margin-left: 8px;
        }

        /* Mini trend chart - interactive */
        .pattern-trend {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 50px;
            margin-top: 12px;
            padding: 0 2px;
        }

        .pattern-trend-bar {
            flex: 1;
            background: linear-gradient(180deg, var(--accent) 0%, rgba(74, 144, 164, 0.4) 100%);
            border-radius: 3px 3px 0 0;
            min-height: 4px;
            transition: all 0.2s ease-out;
            cursor: pointer;
            position: relative;
        }

        .pattern-trend-bar:active {
            transform: scaleX(1.1);
        }

        .pattern-trend-bar.selected {
            background: linear-gradient(180deg, #6bb3c9 0%, var(--accent) 100%);
            box-shadow: 0 0 8px rgba(74, 144, 164, 0.5);
        }

        .pattern-trend-bar.empty {
            background: var(--border-color);
        }

        .pattern-trend-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 10px;
            color: var(--text-muted);
        }

        .pattern-trend-tooltip {
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--text-color);
            color: var(--bg-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s;
            z-index: 10;
        }

        .pattern-trend-bar.selected .pattern-trend-tooltip {
            opacity: 1;
        }

        /* Streak display */
        .pattern-streak {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pattern-streak-flame {
            font-size: 28px;
            line-height: 1;
        }

        .pattern-streak-info {
            flex: 1;
        }

        .pattern-streak-count {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-color);
            line-height: 1;
        }

        .pattern-streak-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .pattern-streak-best {
            text-align: right;
            font-size: 11px;
            color: var(--text-muted);
        }

        .pattern-streak-best span {
            display: block;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-light);
        }

        /* Time of day blocks - interactive */
        .pattern-time-blocks {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }

        .pattern-time-block {
            flex: 1;
            text-align: center;
            padding: 12px 6px;
            background-color: var(--input-bg);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .pattern-time-block:active {
            transform: scale(0.97);
        }

        .pattern-time-block.active {
            background: linear-gradient(135deg, var(--accent), rgba(74, 144, 164, 0.6));
        }

        .pattern-time-block.selected {
            box-shadow: 0 0 0 2px var(--accent);
        }

        .pattern-time-block-icon {
            font-size: 16px;
            margin-bottom: 4px;
        }

        .pattern-time-block-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 2px;
        }

        .pattern-time-block.active .pattern-time-block-label {
            color: rgba(255,255,255,0.8);
        }

        .pattern-time-block-value {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-light);
        }

        .pattern-time-block.active .pattern-time-block-value {
            color: white;
        }

        /* Balance meter - interactive */
        .pattern-balance {
            margin-top: 12px;
        }

        .pattern-balance-bar {
            height: 12px;
            background-color: var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            cursor: pointer;
            transition: height 0.15s;
        }

        .pattern-balance-bar:active {
            height: 14px;
        }

        .pattern-balance-captured {
            background: linear-gradient(90deg, #f0ad4e, #e09530);
            transition: width 0.4s ease-out;
            position: relative;
        }

        .pattern-balance-completed {
            background: linear-gradient(90deg, #5cb85c, #4caf50);
            transition: width 0.4s ease-out;
        }

        .pattern-balance-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
        }

        .pattern-balance-label {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-muted);
        }

        .pattern-balance-label span {
            font-weight: 600;
            color: var(--text-light);
        }

        .pattern-balance-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .pattern-balance-dot.captured {
            background-color: #f0ad4e;
        }

        .pattern-balance-dot.completed {
            background-color: #5cb85c;
        }

        /* Compact stat inline */
        .pattern-stat-inline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .pattern-stat-inline:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .pattern-stat-inline-label {
            font-size: 13px;
            color: var(--text-muted);
        }

        .pattern-stat-inline-value {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-color);
        }

        .pattern-stat-inline-value.positive {
            color: var(--done-color);
        }

        .pattern-stat-inline-value.highlight {
            color: var(--accent);
        }

        /* Insight card with icon */
        .pattern-insight {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 14px;
            background-color: var(--input-bg);
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .pattern-insight:last-child {
            margin-bottom: 0;
        }

        .pattern-insight-icon {
            font-size: 18px;
            line-height: 1;
            margin-top: 1px;
        }

        .pattern-insight-text {
            flex: 1;
            font-size: 13px;
            color: var(--text-light);
            line-height: 1.5;
        }

        .pattern-insight-highlight {
            color: var(--text-color);
            font-weight: 600;
        }

        /* Tappable quote item */
        .pattern-quote-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.15s;
            margin: 0 -8px;
            padding-left: 8px;
            padding-right: 8px;
            border-radius: 8px;
        }

        .pattern-quote-item:last-child {
            border-bottom: none;
        }

        .pattern-quote-item:active {
            background-color: rgba(255,255,255,0.03);
        }

        .pattern-quote-text {
            flex: 1;
            font-size: 14px;
            color: var(--text-light);
            line-height: 1.4;
        }

        .pattern-quote-meta {
            font-size: 11px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        /* Detail row expandable */
        .pattern-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 12px;
            color: var(--text-muted);
        }

        .pattern-detail-row span {
            color: var(--text-light);
        }

        /* Tap hint */
        .pattern-tap-hint {
            font-size: 10px;
            color: var(--text-muted);
            text-align: center;
            margin-top: 8px;
            opacity: 0.7;
        }

        .backlog-item-wrapper {
            position: relative;
            margin-bottom: 10px;
            border-radius: 10px;
            overflow: hidden;
        }

        .backlog-item-wrapper.removing {
            transition: max-height 0.3s, opacity 0.3s, margin 0.3s;
            max-height: 0;
            opacity: 0;
            margin: 0;
            overflow: hidden;
        }

        .backlog-swipe-bg {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 500;
            color: white;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .backlog-swipe-delete {
            background-color: #e74c3c;
            justify-content: flex-end;
        }

        .backlog-swipe-delete.confirm {
            justify-content: center;
            cursor: pointer;
        }

        .backlog-item {
            padding: 16px 18px;
            background-color: var(--card-bg);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            position: relative;
            touch-action: pan-y pinch-zoom;
            transition: transform 0.1s, box-shadow 0.1s;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .backlog-item.swiping {
            transition: none;
        }

        .backlog-item.dragging {
            opacity: 0.9;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 10;
            transform: scale(1.02);
        }

        .backlog-item-text {
            font-size: 15px;
            line-height: 1.4;
            color: var(--text-color);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .backlog-item-meta {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            gap: 12px;
        }

        .backlog-item-meta span {
            opacity: 0.8;
        }

        .backlog-placeholder {
            background-color: var(--border-color);
            border-radius: 10px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* ===== TAB BAR ===== */
        #tab-bar {
            display: flex;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            padding-bottom: max(20px, calc(env(safe-area-inset-bottom) + 8px));
        }

        .tab-button {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 11px;
            padding: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .tab-button svg {
            width: 22px;
            height: 22px;
        }

        .tab-button.active {
            color: var(--accent);
        }

        /* Icon button styling */
        .tab-top-btn svg,
        #settings-close svg {
            display: block;
        }
    </style>
</head>
<body>

    <!-- SETTINGS PANEL -->
    <div id="settings-panel">
        <button id="settings-close">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <div id="settings-title">settings</div>

        <div class="settings-section">
            <div class="settings-section-title">Notifications</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Bedtime reminder<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Prompt to capture thoughts before sleep</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-bedtime-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Morning focus<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Daily reminder of your focus items</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-morning-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Periodic reminders<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Gentle nudges throughout the day</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-periodic-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Display</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Daily focus items</div>
                    <div class="settings-item-desc">How many tasks to show each day</div>
                </div>
                <select id="setting-daily-items" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="5">5</option>
                </select>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Bedtime Mode</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Starts at</div>
                    <div class="settings-item-desc">When bedtime mode activates</div>
                </div>
                <select id="setting-bedtime-start" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="20">8 pm</option>
                    <option value="21" selected>9 pm</option>
                    <option value="22">10 pm</option>
                    <option value="23">11 pm</option>
                </select>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Ends at</div>
                    <div class="settings-item-desc">When bedtime mode turns off</div>
                </div>
                <select id="setting-bedtime-end" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="5">5 am</option>
                    <option value="6" selected>6 am</option>
                    <option value="7">7 am</option>
                    <option value="8">8 am</option>
                </select>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Backup</div>
            <div class="settings-item-desc" style="margin-bottom: 15px;">Your data is stored locally. Back up regularly to avoid losing it.</div>

            <button class="dev-button" onclick="backupToClipboard()" style="margin-bottom: 8px;">
                Copy Backup to Clipboard
                <div class="dev-button-desc">Quick backup - paste into Notes or anywhere</div>
            </button>
            <button class="dev-button" onclick="restoreFromClipboard()">
                Restore from Clipboard
                <div class="dev-button-desc">Paste a previous backup to restore</div>
            </button>
            <div id="last-backup-info" style="font-size: 12px; color: var(--text-muted); margin-top: 12px; text-align: center;"></div>
        </div>

        <!-- Dev Tools Section -->
        <div class="dev-tools-section">
            <div class="settings-section-title">Dev Tools</div>
            <div class="dev-tools-warning">Testing only. Changes affect your real data.</div>

            <div class="dev-subsection">Generate Sample Data</div>
            <button class="dev-button" onclick="devGenerateThoughts()">
                Generate Sample Thoughts
                <div class="dev-button-desc">Add 10 thoughts with varied ages (1 day to 3 weeks old)</div>
            </button>
            <button class="dev-button" onclick="devGenerateCompleted()">
                Generate Completed Items
                <div class="dev-button-desc">Add 15 completed items over past 2 weeks</div>
            </button>
            <button class="dev-button" onclick="devGenerateWorries()">
                Generate Worries
                <div class="dev-button-desc">Add 5 sample worries</div>
            </button>
            <button class="dev-button" onclick="devGenerateSkipped()">
                Generate Skipped Items
                <div class="dev-button-desc">Add items with high skip counts</div>
            </button>
            <button class="dev-button" onclick="devGenerateReflections()">
                Generate Weekly Reflections
                <div class="dev-button-desc">Add 4 weeks of reflection history</div>
            </button>

            <div class="dev-subsection">Triggers</div>
            <button class="dev-button" onclick="devTriggerMorning()">
                Show Morning Banner Now
                <div class="dev-button-desc">Force show regardless of time</div>
            </button>
            <button class="dev-button" onclick="devTriggerWeekly()">
                Show Weekly Banner Now
                <div class="dev-button-desc">Force show regardless of day/time</div>
            </button>

            <div class="dev-subsection">Data Management</div>
            <button class="dev-button" onclick="devExportData()">
                Export All Data
                <div class="dev-button-desc">Download as JSON file</div>
            </button>
            <button class="dev-button danger" onclick="devClearAllData()">
                Clear All Data
                <div class="dev-button-desc">Remove all thoughts, completions, and reflections</div>
            </button>
        </div>

    </div>

    <!-- TABS -->
    <div id="tabs-container">
        <div id="tabs-track">
            <!-- CAPTURE TAB -->
            <div id="capture-tab" class="tab-content">
                <div class="tab-top-row">
                    <button class="tab-top-btn" data-action="settings">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="tab-top-btn" data-action="bedtime">
                        <svg class="icon-moon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg class="icon-sun" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </button>
                </div>
                <!-- Morning intention banner -->
                <div id="morning-banner">
                    <div class="morning-header">
                        <div class="morning-greeting">good morning</div>
                        <button class="morning-close" id="morning-close">&times;</button>
                    </div>
                    <div class="morning-prompt">here's what's on your plate today:</div>
                    <div id="morning-focus-list"></div>
                    <button class="morning-action" id="morning-action">let's do this</button>
                </div>

                <!-- Weekly reflection banner -->
                <div id="weekly-banner">
                    <div class="weekly-header">
                        <div class="weekly-greeting">week in review</div>
                        <button class="weekly-close" id="weekly-close">&times;</button>
                    </div>
                    <div class="weekly-stats">
                        <div class="weekly-stat">
                            <div class="weekly-stat-value" id="weekly-completed">0</div>
                            <div class="weekly-stat-label">completed</div>
                        </div>
                        <div class="weekly-stat">
                            <div class="weekly-stat-value" id="weekly-captured">0</div>
                            <div class="weekly-stat-label">captured</div>
                        </div>
                    </div>
                    <button class="weekly-action" id="weekly-action">save & view patterns</button>
                </div>

                <div id="mic-container">
                    <div class="ripple ripple-1"></div>
                    <div class="ripple ripple-2"></div>
                    <button id="big-mic-button">tap to drop</button>
                </div>
                <div id="capture-confirmation"></div>
                <div id="text-input-section">
                    <input type="text" id="thought-input" placeholder="or type here">
                </div>
                <div id="capture-swipe-hint">
                    <svg class="hint-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="18 15 12 9 6 15"></polyline>
                    </svg>
                    <span>today's focus</span>
                </div>
            </div>

            <!-- TODAY TAB -->
            <div id="today-tab" class="tab-content">
                <div class="tab-top-row">
                    <button class="tab-top-btn" data-action="settings">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="tab-top-btn" data-action="bedtime">
                        <svg class="icon-moon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg class="icon-sun" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </button>
                </div>
                <div id="old-items-section" style="display: none;">
                    <div class="section-title">been on your mind</div>
                    <ul id="old-items-list" class="task-list"></ul>
                </div>

                <div class="section-title">for later</div>
                <ul id="later-list" class="task-list"></ul>

                <div class="section-title">done</div>
                <ul id="completed-today-list" class="task-list"></ul>
            </div>

            <!-- ALL TAB -->
            <div id="all-tab" class="tab-content">
                <div class="tab-top-row">
                    <button class="tab-top-btn" data-action="settings">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="tab-top-btn" data-action="bedtime">
                        <svg class="icon-moon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg class="icon-sun" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </button>
                </div>
                <div class="section-title">backlog</div>
                <div id="backlog-list"></div>
            </div>

            <!-- PATTERNS TAB -->
            <div id="patterns-tab" class="tab-content">
                <div class="tab-top-row">
                    <button class="tab-top-btn" data-action="settings">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="tab-top-btn" data-action="bedtime">
                        <svg class="icon-moon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg class="icon-sun" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </button>
                </div>
                <div class="section-title">patterns</div>
                <div id="patterns-container"></div>
            </div>
        </div>
    </div>

    <!-- FOCUS OVERLAY -->
    <div id="focus-overlay">
        <div id="focus-handle">
            <div class="handle-pill"></div>
        </div>
        <div id="focus-cards-container">
            <!-- Cards or message will be rendered here -->
        </div>
    </div>

    <!-- TAB BAR -->
    <div id="tab-bar">
        <button class="tab-button active" data-tab="capture-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
            <span>Drop</span>
        </button>
        <button class="tab-button" data-tab="today-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="6"></circle>
                <circle cx="12" cy="12" r="2"></circle>
            </svg>
            <span>Today</span>
        </button>
        <button class="tab-button" data-tab="all-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="8" y1="6" x2="21" y2="6"></line>
                <line x1="8" y1="12" x2="21" y2="12"></line>
                <line x1="8" y1="18" x2="21" y2="18"></line>
                <line x1="3" y1="6" x2="3.01" y2="6"></line>
                <line x1="3" y1="12" x2="3.01" y2="12"></line>
                <line x1="3" y1="18" x2="3.01" y2="18"></line>
            </svg>
            <span>All</span>
        </button>
        <button class="tab-button" data-tab="patterns-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="20" x2="18" y2="10"></line>
                <line x1="12" y1="20" x2="12" y2="4"></line>
                <line x1="6" y1="20" x2="6" y2="14"></line>
            </svg>
            <span>Patterns</span>
        </button>
    </div>

    <script>
        // ===== DATA MODEL =====
        let thoughts = JSON.parse(localStorage.getItem('thoughts')) || [];
        let todayFocus = JSON.parse(localStorage.getItem('todayFocus')) || [];
        let laterToday = JSON.parse(localStorage.getItem('laterToday')) || [];
        let completedToday = JSON.parse(localStorage.getItem('completedToday')) || [];
        let completedAllTime = JSON.parse(localStorage.getItem('completedAllTime')) || [];
        let worries = JSON.parse(localStorage.getItem('worries')) || [];
        let weeklyReflections = JSON.parse(localStorage.getItem('weeklyReflections')) || [];
        let lastResetDate = localStorage.getItem('lastResetDate') || '';

        // Migrate old formats
        thoughts = thoughts.map(item => {
            if (typeof item === 'string') {
                return { text: item, skips: 0, createdAt: Date.now() };
            }
            if (!item.createdAt) {
                item.createdAt = Date.now();
            }
            return item;
        });

        // Migrate completedAllTime from strings to objects
        completedAllTime = completedAllTime.map(item => {
            if (typeof item === 'string') {
                return { text: item, completedAt: Date.now() };
            }
            return item;
        });

        function saveAll() {
            localStorage.setItem('thoughts', JSON.stringify(thoughts));
            localStorage.setItem('todayFocus', JSON.stringify(todayFocus));
            localStorage.setItem('laterToday', JSON.stringify(laterToday));
            localStorage.setItem('completedToday', JSON.stringify(completedToday));
            localStorage.setItem('completedAllTime', JSON.stringify(completedAllTime));
            localStorage.setItem('worries', JSON.stringify(worries));
            localStorage.setItem('weeklyReflections', JSON.stringify(weeklyReflections));
            localStorage.setItem('lastResetDate', lastResetDate);
        }

        function getTodayDate() {
            return new Date().toDateString();
        }

        function checkDailyReset() {
            const today = getTodayDate();
            if (lastResetDate !== today) {
                // New day - reset
                laterToday = [];
                completedToday = [];
                lastResetDate = today;
                selectTodayFocus();
                saveAll();
            }
        }

        function selectTodayFocus() {
            const count = parseInt(localStorage.getItem('dailyFocusItems') || '3');
            todayFocus = thoughts.slice(0, count).map(t => ({ ...t }));
        }

        // Initialize on load
        checkDailyReset();
        if (todayFocus.length === 0 && thoughts.length > 0) {
            selectTodayFocus();
            saveAll();
        }

        // Track focus overlay state (used by tab swiping)
        let focusVisible = false;

        // ===== SETTINGS =====
        const settingsPanel = document.getElementById('settings-panel');
        const settingsClose = document.getElementById('settings-close');
        const settingDailyItems = document.getElementById('setting-daily-items');

        settingsClose.addEventListener('click', () => settingsPanel.classList.remove('visible'));

        const savedDailyItems = localStorage.getItem('dailyFocusItems') || '3';
        settingDailyItems.value = savedDailyItems;

        settingDailyItems.addEventListener('change', function() {
            localStorage.setItem('dailyFocusItems', this.value);
            selectTodayFocus();
            saveAll();
            renderFocusCards();
        });

        // ===== PATTERNS =====
        function renderPatterns() {
            const container = document.getElementById('patterns-container');
            const now = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;
            const oneWeekAgo = now - (7 * oneDay);
            const twoWeeksAgo = now - (14 * oneDay);
            const fourWeeksAgo = now - (28 * oneDay);

            // Calculate all stats upfront
            const totalCapturedTasks = thoughts.length + completedAllTime.length;
            const totalCaptured = totalCapturedTasks + worries.length;
            const totalCompleted = completedAllTime.length;
            const backlogSize = thoughts.length;
            const worriesReleased = worries.length;

            // Weekly stats
            const thisWeekCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > oneWeekAgo).length;
            const lastWeekCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > twoWeeksAgo && t.completedAt <= oneWeekAgo).length;
            const thisWeekCaptured = [...thoughts, ...completedAllTime].filter(t => t.createdAt && t.createdAt > oneWeekAgo).length;

            // Completion timestamps for time analysis
            const completionTimestamps = completedAllTime.map(t => t.completedAt).filter(Boolean);
            const completedWithTimes = completedAllTime.filter(t => t.createdAt && t.completedAt);

            // Day of week analysis
            const completionDayCounts = [0, 0, 0, 0, 0, 0, 0];
            const captureDayCounts = [0, 0, 0, 0, 0, 0, 0];
            completedAllTime.forEach(t => {
                if (t.completedAt) completionDayCounts[new Date(t.completedAt).getDay()]++;
            });
            [...thoughts, ...completedAllTime].forEach(t => {
                if (t.createdAt) captureDayCounts[new Date(t.createdAt).getDay()]++;
            });

            // Time of day analysis
            const timeBlocks = { morning: 0, afternoon: 0, evening: 0, night: 0 };
            completionTimestamps.forEach(ts => {
                const hour = new Date(ts).getHours();
                if (hour >= 5 && hour < 12) timeBlocks.morning++;
                else if (hour >= 12 && hour < 17) timeBlocks.afternoon++;
                else if (hour >= 17 && hour < 21) timeBlocks.evening++;
                else timeBlocks.night++;
            });

            // Streak calculation
            let currentStreak = 0;
            let bestStreak = 0;
            let checkDate = new Date();
            checkDate.setHours(0, 0, 0, 0);
            const todayStart = checkDate.getTime();
            const hasCompletedToday = completedAllTime.some(t =>
                t.completedAt && t.completedAt >= todayStart && t.completedAt < todayStart + oneDay
            );
            if (!hasCompletedToday) checkDate.setDate(checkDate.getDate() - 1);
            while (currentStreak <= 365) {
                const dayStart = checkDate.getTime();
                if (completedAllTime.some(t => t.completedAt && t.completedAt >= dayStart && t.completedAt < dayStart + oneDay)) {
                    currentStreak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                } else break;
            }
            // Calculate best streak (simplified - check last 90 days)
            let tempStreak = 0;
            for (let d = 0; d < 90; d++) {
                const dayStart = now - (d * oneDay);
                const dayEnd = dayStart + oneDay;
                if (completedAllTime.some(t => t.completedAt && t.completedAt >= dayStart - oneDay && t.completedAt < dayEnd - oneDay)) {
                    tempStreak++;
                    bestStreak = Math.max(bestStreak, tempStreak);
                } else {
                    tempStreak = 0;
                }
            }
            bestStreak = Math.max(bestStreak, currentStreak);

            // Not enough data
            if (totalCaptured < 3) {
                container.innerHTML = '<div class="empty-section">capture a few more thoughts to see patterns</div>';
                return;
            }

            let html = '';

            // 
            // SECTION: OVERVIEW
            // 
            html += `<div class="pattern-section">
                <div class="pattern-section-header">
                    <span class="pattern-section-title">Overview</span>
                </div>`;

            // Key stats row
            const completionRate = totalCapturedTasks > 0 ? Math.round((totalCompleted / totalCapturedTasks) * 100) : 0;
            html += '<div class="pattern-row-3">';
            html += `<div class="pattern-card highlight">
                <div class="pattern-card-label">done</div>
                <div class="pattern-card-value">${totalCompleted}</div>
            </div>`;
            html += `<div class="pattern-card">
                <div class="pattern-card-label">waiting</div>
                <div class="pattern-card-value">${backlogSize}</div>
            </div>`;
            html += `<div class="pattern-card${completionRate >= 50 ? ' highlight-green' : ''}">
                <div class="pattern-card-label">rate</div>
                <div class="pattern-card-value">${completionRate}%</div>
            </div>`;
            html += '</div>';

            // Streak (if exists)
            if (currentStreak >= 1) {
                html += `<div class="pattern-card${currentStreak >= 3 ? ' highlight' : ''}">
                    <div class="pattern-streak">
                        <span class="pattern-streak-flame">${currentStreak >= 7 ? '' : currentStreak >= 3 ? '' : ''}</span>
                        <div class="pattern-streak-info">
                            <div class="pattern-streak-count">${currentStreak}</div>
                            <div class="pattern-streak-label">${currentStreak === 1 ? 'day' : 'days'} in a row</div>
                        </div>
                        ${bestStreak > currentStreak ? `<div class="pattern-streak-best">best<span>${bestStreak}</span></div>` : ''}
                    </div>
                </div>`;
            }

            html += '</div>'; // end overview section

            // 
            // SECTION: THIS WEEK
            // 
            if (thisWeekCompleted > 0 || thisWeekCaptured > 0 || lastWeekCompleted > 0) {
                html += `<div class="pattern-section">
                    <div class="pattern-section-header">
                        <span class="pattern-section-title">This Week</span>
                    </div>`;

                // Week comparison
                let weekTrend = '';
                let weekHighlight = false;
                if (lastWeekCompleted > 0 && thisWeekCompleted > lastWeekCompleted) {
                    const pctUp = Math.round(((thisWeekCompleted - lastWeekCompleted) / lastWeekCompleted) * 100);
                    weekTrend = `+${pctUp}%`;
                    weekHighlight = true;
                } else if (lastWeekCompleted > 0 && thisWeekCompleted < lastWeekCompleted) {
                    const pctDown = Math.round(((lastWeekCompleted - thisWeekCompleted) / lastWeekCompleted) * 100);
                    weekTrend = `-${pctDown}%`;
                }

                html += `<div class="pattern-card${weekHighlight ? ' highlight' : ''}">
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Completed</span>
                        <span class="pattern-stat-inline-value${weekHighlight ? ' positive' : ''}">${thisWeekCompleted}${weekTrend ? ` (${weekTrend})` : ''}</span>
                    </div>
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Captured</span>
                        <span class="pattern-stat-inline-value">${thisWeekCaptured}</span>
                    </div>
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Last week</span>
                        <span class="pattern-stat-inline-value">${lastWeekCompleted} completed</span>
                    </div>
                </div>`;

                // Daily breakdown (interactive)
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const todayDay = new Date().getDay();
                const weekDayCounts = dayNames.map(() => 0);
                completedAllTime.forEach(t => {
                    if (t.completedAt && t.completedAt > oneWeekAgo) {
                        weekDayCounts[new Date(t.completedAt).getDay()]++;
                    }
                });
                const maxDayThisWeek = Math.max(...weekDayCounts, 1);

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">daily breakdown <span style="font-weight: normal; text-transform: none;">(tap for details)</span></div>
                    <div class="pattern-bar-container" id="daily-bars">`;
                dayNames.forEach((name, i) => {
                    const count = weekDayCounts[i];
                    const pct = Math.round((count / maxDayThisWeek) * 100);
                    const isToday = i === todayDay;
                    html += `<div class="pattern-bar-row${isToday ? ' selected' : ''}" data-day="${name}" data-count="${count}">
                        <div class="pattern-bar-label">${name}</div>
                        <div class="pattern-bar-track">
                            <div class="pattern-bar-fill" style="width: ${pct}%; ${isToday ? 'background: linear-gradient(90deg, #5cb85c, #4caf50);' : ''}"></div>
                        </div>
                        <div class="pattern-bar-value">${count}</div>
                    </div>`;
                });
                html += '</div></div>';

                html += '</div>'; // end this week section
            }

            // 
            // SECTION: TRENDS
            // 
            const weeklyData = [];
            const weekLabels = [];
            for (let i = 7; i >= 0; i--) {
                const weekStart = now - ((i + 1) * 7 * oneDay);
                const weekEnd = now - (i * 7 * oneDay);
                const count = completedAllTime.filter(t => t.completedAt && t.completedAt > weekStart && t.completedAt <= weekEnd).length;
                weeklyData.push(count);
                const weekDate = new Date(weekEnd);
                weekLabels.push(`${weekDate.getMonth() + 1}/${weekDate.getDate()}`);
            }
            const maxWeekly = Math.max(...weeklyData, 1);
            const totalWeeklySum = weeklyData.reduce((a, b) => a + b, 0);

            if (totalWeeklySum > 0) {
                html += `<div class="pattern-section">
                    <div class="pattern-section-header">
                        <span class="pattern-section-title">Trends</span>
                    </div>`;

                // Weekly trend chart (interactive)
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">8-week history <span style="font-weight: normal; text-transform: none;">(tap bars)</span></div>
                    <div class="pattern-trend" id="weekly-trend">`;
                weeklyData.forEach((count, i) => {
                    const height = Math.max(4, Math.round((count / maxWeekly) * 50));
                    html += `<div class="pattern-trend-bar${count === 0 ? ' empty' : ''}" style="height: ${height}px" data-count="${count}" data-week="${weekLabels[i]}">
                        <div class="pattern-trend-tooltip">${count} done<br>${weekLabels[i]}</div>
                    </div>`;
                });
                html += `</div>
                    <div class="pattern-trend-labels">
                        <span>8 wks ago</span>
                        <span>now</span>
                    </div>
                    <div class="pattern-tap-hint">tap a bar for exact count</div>
                </div>`;

                // Capture vs Complete balance
                const recentCaptured = [...thoughts, ...completedAllTime].filter(t => t.createdAt && t.createdAt > fourWeeksAgo).length;
                const recentCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > fourWeeksAgo).length;

                if (recentCaptured > 0 || recentCompleted > 0) {
                    const total = recentCaptured + recentCompleted;
                    const capturedPct = Math.round((recentCaptured / total) * 100);
                    const completedPct = 100 - capturedPct;
                    let flowStatus = recentCompleted >= recentCaptured ? 'Clearing backlog' :
                                     recentCaptured > recentCompleted * 1.5 ? 'Building backlog' : 'Balanced';

                    html += `<div class="pattern-card">
                        <div class="pattern-card-label">4-week flow</div>
                        <div class="pattern-balance">
                            <div class="pattern-balance-bar" id="balance-bar" data-captured="${recentCaptured}" data-completed="${recentCompleted}">
                                <div class="pattern-balance-captured" style="width: ${capturedPct}%"></div>
                                <div class="pattern-balance-completed" style="width: ${completedPct}%"></div>
                            </div>
                            <div class="pattern-balance-labels">
                                <div class="pattern-balance-label">
                                    <span class="pattern-balance-dot captured"></span>
                                    <span>${recentCaptured}</span> in
                                </div>
                                <div class="pattern-balance-label">
                                    <span class="pattern-balance-dot completed"></span>
                                    <span>${recentCompleted}</span> out
                                </div>
                            </div>
                        </div>
                        <div class="pattern-card-detail">${flowStatus}</div>
                    </div>`;
                }

                html += '</div>'; // end trends section
            }

            // 
            // SECTION: YOUR RHYTHM
            // 
            if (completionTimestamps.length >= 5) {
                html += `<div class="pattern-section">
                    <div class="pattern-section-header">
                        <span class="pattern-section-title">Your Rhythm</span>
                    </div>`;

                // Time of day blocks (interactive)
                const maxBlock = Math.max(...Object.values(timeBlocks), 1);
                const activeBlock = Object.entries(timeBlocks).reduce((a, b) => b[1] > a[1] ? b : a)[0];
                const timeIcons = { morning: '', afternoon: '', evening: '', night: '' };
                const timeRanges = { morning: '5am-12pm', afternoon: '12-5pm', evening: '5-9pm', night: '9pm-5am' };

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">peak productivity <span style="font-weight: normal; text-transform: none;">(tap to see time range)</span></div>
                    <div class="pattern-time-blocks" id="time-blocks">
                        ${Object.entries(timeBlocks).map(([period, count]) => `
                            <div class="pattern-time-block${period === activeBlock ? ' active' : ''}" data-period="${period}" data-range="${timeRanges[period]}" data-count="${count}">
                                <div class="pattern-time-block-icon">${timeIcons[period]}</div>
                                <div class="pattern-time-block-label">${period}</div>
                                <div class="pattern-time-block-value">${count}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>`;

                // Best day + avg time combined
                const maxDayCount = Math.max(...completionDayCounts);
                const dayNamesFull = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const bestDay = dayNamesFull[completionDayCounts.indexOf(maxDayCount)];

                let avgTimeText = '';
                if (completedWithTimes.length >= 3) {
                    const avgMs = completedWithTimes.reduce((sum, t) => sum + (t.completedAt - t.createdAt), 0) / completedWithTimes.length;
                    const avgDays = avgMs / oneDay;
                    if (avgDays < 1) {
                        const hrs = Math.round(avgMs / (60 * 60 * 1000));
                        avgTimeText = hrs <= 1 ? '< 1 hour' : `${hrs} hours`;
                    } else if (avgDays < 7) {
                        avgTimeText = `${Math.round(avgDays)} days`;
                    } else {
                        avgTimeText = `${Math.round(avgDays / 7)} weeks`;
                    }
                }

                html += `<div class="pattern-card">
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Best day</span>
                        <span class="pattern-stat-inline-value highlight">${bestDay}</span>
                    </div>
                    ${avgTimeText ? `<div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Avg time to done</span>
                        <span class="pattern-stat-inline-value">${avgTimeText}</span>
                    </div>` : ''}
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Weekend vs weekday</span>
                        <span class="pattern-stat-inline-value">${completionDayCounts[0] + completionDayCounts[6]} / ${completionDayCounts.slice(1, 6).reduce((a, b) => a + b, 0)}</span>
                    </div>
                </div>`;

                html += '</div>'; // end rhythm section
            }

            // 
            // SECTION: BACKLOG HEALTH
            // 
            const thoughtsWithDates = thoughts.filter(t => t.createdAt);
            const frequentlySkipped = thoughts.filter(t => t.skips >= 2).sort((a, b) => b.skips - a.skips);
            const oldest = thoughtsWithDates.length > 0 ? thoughtsWithDates.reduce((a, b) => a.createdAt < b.createdAt ? a : b) : null;
            const oldestDays = oldest ? Math.floor((now - oldest.createdAt) / oneDay) : 0;

            if (backlogSize > 0 && (oldestDays >= 3 || frequentlySkipped.length > 0)) {
                html += `<div class="pattern-section">
                    <div class="pattern-section-header">
                        <span class="pattern-section-title">Backlog Health</span>
                    </div>`;

                // Backlog age distribution
                const ageGroups = { fresh: 0, week: 0, twoWeeks: 0, older: 0 };
                thoughtsWithDates.forEach(t => {
                    const age = (now - t.createdAt) / oneDay;
                    if (age < 3) ageGroups.fresh++;
                    else if (age < 7) ageGroups.week++;
                    else if (age < 14) ageGroups.twoWeeks++;
                    else ageGroups.older++;
                });

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">age distribution</div>
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Fresh (< 3 days)</span>
                        <span class="pattern-stat-inline-value positive">${ageGroups.fresh}</span>
                    </div>
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">This week</span>
                        <span class="pattern-stat-inline-value">${ageGroups.week}</span>
                    </div>
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">1-2 weeks</span>
                        <span class="pattern-stat-inline-value">${ageGroups.twoWeeks}</span>
                    </div>
                    <div class="pattern-stat-inline">
                        <span class="pattern-stat-inline-label">Older</span>
                        <span class="pattern-stat-inline-value${ageGroups.older > 3 ? '' : ''}">${ageGroups.older}</span>
                    </div>
                </div>`;

                // Oldest + frequently skipped
                if (oldestDays >= 3 || frequentlySkipped.length > 0) {
                    html += `<div class="pattern-card">
                        <div class="pattern-card-label">needs attention</div>`;

                    if (oldest && oldestDays >= 3) {
                        const truncated = oldest.text.length > 40 ? oldest.text.slice(0, 40) + '...' : oldest.text;
                        const timeStr = oldestDays >= 14 ? `${Math.floor(oldestDays / 7)} weeks` : `${oldestDays} days`;
                        html += `<div class="pattern-quote-item" data-action="oldest">
                            <div class="pattern-quote-text">"${truncated}"</div>
                            <div class="pattern-quote-meta">${timeStr}</div>
                        </div>`;
                    }

                    frequentlySkipped.slice(0, 2).forEach(item => {
                        const truncated = item.text.length > 40 ? item.text.slice(0, 40) + '...' : item.text;
                        html += `<div class="pattern-quote-item">
                            <div class="pattern-quote-text">"${truncated}"</div>
                            <div class="pattern-quote-meta">skipped ${item.skips}x</div>
                        </div>`;
                    });

                    html += '</div>';
                }

                html += '</div>'; // end backlog health section
            }

            // 
            // SECTION: INSIGHTS
            // 
            const insights = [];

            // Generate insights
            if (completedWithTimes.length >= 3) {
                const avgDays = completedWithTimes.reduce((sum, t) => sum + (t.completedAt - t.createdAt), 0) / completedWithTimes.length / oneDay;
                if (avgDays < 2) {
                    insights.push({ icon: '', text: `<span class="pattern-insight-highlight">Fast executor</span>  most items done within ${Math.round(avgDays * 24)} hours` });
                }
            }

            const weekendTotal = completionDayCounts[0] + completionDayCounts[6];
            const weekdayTotal = completionDayCounts.slice(1, 6).reduce((a, b) => a + b, 0);
            if (weekendTotal > weekdayTotal && weekendTotal >= 3) {
                insights.push({ icon: '', text: `<span class="pattern-insight-highlight">Weekend warrior</span>  you get more done on Sat/Sun` });
            }

            if (completionTimestamps.length >= 5) {
                const morningPct = timeBlocks.morning / completionTimestamps.length;
                const nightPct = (timeBlocks.night) / completionTimestamps.length;
                if (morningPct > 0.5) {
                    insights.push({ icon: '', text: `<span class="pattern-insight-highlight">Morning person</span>  ${Math.round(morningPct * 100)}% of completions before noon` });
                } else if (nightPct > 0.3) {
                    insights.push({ icon: '', text: `<span class="pattern-insight-highlight">Night owl</span>  you often get things done late at night` });
                }
            }

            if (currentStreak >= 7) {
                insights.push({ icon: '', text: `<span class="pattern-insight-highlight">${currentStreak} day streak!</span>  consistently completing tasks` });
            }

            if (totalCompleted > backlogSize * 2 && totalCompleted >= 10) {
                insights.push({ icon: '', text: `<span class="pattern-insight-highlight">Backlog clearer</span>  ${totalCompleted} done, more than 2x your waiting list` });
            }

            if (worriesReleased >= 3) {
                insights.push({ icon: '', text: `<span class="pattern-insight-highlight">${worriesReleased} worries released</span>  captured and let go` });
            }

            if (insights.length > 0) {
                html += `<div class="pattern-section">
                    <div class="pattern-section-header">
                        <span class="pattern-section-title">About You</span>
                    </div>`;
                insights.slice(0, 4).forEach(insight => {
                    html += `<div class="pattern-insight">
                        <span class="pattern-insight-icon">${insight.icon}</span>
                        <span class="pattern-insight-text">${insight.text}</span>
                    </div>`;
                });
                html += '</div>';
            }

            // 
            // SECTION: HISTORY (Weekly Reflections)
            // 
            if (weeklyReflections.length > 0) {
                html += `<div class="pattern-section">
                    <div class="pattern-section-header">
                        <span class="pattern-section-title">History</span>
                    </div>`;
                weeklyReflections.forEach(reflection => {
                    const date = new Date(reflection.date);
                    const weekLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    html += `<div class="reflection-card">
                        <div class="reflection-week">Week of ${weekLabel}</div>
                        <div class="reflection-stats">
                            <div class="reflection-stat"><span>${reflection.completed}</span> completed</div>
                            <div class="reflection-stat"><span>${reflection.captured}</span> captured</div>
                        </div>
                    </div>`;
                });
                html += '</div>';
            }

            container.innerHTML = html;

            // Add interactivity after rendering
            setupPatternInteractivity();
        }

        function setupPatternInteractivity() {
            // Weekly trend bar tap
            const trendBars = document.querySelectorAll('#weekly-trend .pattern-trend-bar');
            trendBars.forEach(bar => {
                bar.addEventListener('click', () => {
                    trendBars.forEach(b => b.classList.remove('selected'));
                    bar.classList.add('selected');
                });
            });

            // Daily breakdown bar tap
            const dailyBars = document.querySelectorAll('#daily-bars .pattern-bar-row');
            dailyBars.forEach(bar => {
                bar.addEventListener('click', () => {
                    const wasSelected = bar.classList.contains('selected');
                    dailyBars.forEach(b => b.classList.remove('selected'));
                    if (!wasSelected) bar.classList.add('selected');
                });
            });

            // Time block tap
            const timeBlocks = document.querySelectorAll('#time-blocks .pattern-time-block');
            timeBlocks.forEach(block => {
                block.addEventListener('click', () => {
                    const wasSelected = block.classList.contains('selected');
                    timeBlocks.forEach(b => b.classList.remove('selected'));
                    if (!wasSelected) {
                        block.classList.add('selected');
                        // Could show time range tooltip here
                    }
                });
            });
        }

        // ===== TAB SWITCHING =====
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabsTrack = document.getElementById('tabs-track');
        const tabIds = ['capture-tab', 'today-tab', 'all-tab', 'patterns-tab'];
        let currentTabIndex = 0;

        function switchToTab(index, animate = true) {
            if (index < 0 || index >= tabIds.length) return;
            currentTabIndex = index;

            tabButtons.forEach(b => b.classList.remove('active'));
            tabButtons[index].classList.add('active');

            if (animate) {
                tabsTrack.classList.add('animating');
            }
            tabsTrack.style.transform = `translateX(${-index * 100}vw)`;

            if (animate) {
                setTimeout(() => tabsTrack.classList.remove('animating'), 300);
            }

            if (tabIds[index] === 'today-tab') renderTodayTab();
            if (tabIds[index] === 'all-tab') renderAllTab();
            if (tabIds[index] === 'patterns-tab') renderPatterns();
        }

        tabButtons.forEach((btn, index) => {
            btn.addEventListener('click', function() {
                switchToTab(index);
            });
        });

        // Swipe between tabs
        let tabSwipeStartX = 0;
        let tabSwipeStartY = 0;
        let tabSwipeStartTime = 0;
        let tabSwiping = false;
        let tabSwipeConfirmed = false;
        let tabSwipePending = false; // Started on card, but might become tab swipe
        let cardSwipeInProgress = false; // Global flag for card swipes

        const tabsContainer = document.getElementById('tabs-container');

        tabsContainer.addEventListener('touchstart', e => {
            // Don't start tab swipe if focus overlay is open
            if (focusVisible) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const edgeThreshold = 60; // pixels from screen edge
            const topZone = 120; // pixels from top where tab swipe always works
            const bottomZone = 80; // pixels from bottom where tab swipe always works

            // Always allow tab swipe from screen edges
            const isFromEdge = touchX < edgeThreshold || touchX > screenWidth - edgeThreshold;

            // Allow tab swipe from top zone (section titles area)
            const isFromTopZone = touchY < topZone;

            // Allow tab swipe from bottom zone (near tab bar)
            const isFromBottomZone = touchY > screenHeight - bottomZone;

            tabSwipeStartX = touchX;
            tabSwipeStartY = touchY;
            tabSwipeStartTime = Date.now();
            tabSwipeConfirmed = false;
            tabSwipePending = false;
            tabsTrack.classList.remove('animating');

            if (isFromEdge || isFromTopZone || isFromBottomZone) {
                // Safe zone - definitely a tab swipe
                tabSwiping = true;
            } else {
                // Check if touch started on a swipeable card
                const target = e.target;
                const isOnBacklogItem = target.closest('.backlog-item');
                const isOnFocusCard = target.closest('.focus-card');

                if (isOnBacklogItem || isOnFocusCard) {
                    // Started on card - use pending mode to decide based on gesture
                    tabSwiping = false;
                    tabSwipePending = true;
                } else {
                    tabSwiping = true;
                }
            }
        }, { passive: true });

        tabsContainer.addEventListener('touchmove', e => {
            if (focusVisible) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const diffX = touchX - tabSwipeStartX;
            const diffY = touchY - tabSwipeStartY;
            const elapsed = Date.now() - tabSwipeStartTime;

            // Handle pending swipes (started on card)
            if (tabSwipePending && !tabSwiping) {
                const absX = Math.abs(diffX);
                const absY = Math.abs(diffY);

                // Fast horizontal swipe = tab swipe (velocity check)
                // Speed threshold: 0.5px/ms = fast swipe
                const velocity = absX / Math.max(elapsed, 1);
                const isVeryHorizontal = absX > absY * 3; // More than 3:1 horizontal ratio

                if (absX > 15 && isVeryHorizontal && velocity > 0.4) {
                    // Fast, very horizontal swipe - take over as tab swipe
                    tabSwiping = true;
                    tabSwipePending = false;
                } else if (absX > 30 || absY > 20) {
                    // Gesture has started but not fast/horizontal enough - let card handle it
                    tabSwipePending = false;
                }
            }

            if (!tabSwiping) return;

            // Determine if this is a horizontal swipe
            if (!tabSwipeConfirmed) {
                if (Math.abs(diffY) > Math.abs(diffX) + 10) {
                    tabSwiping = false;
                    return;
                }
                if (Math.abs(diffX) > 10) {
                    tabSwipeConfirmed = true;
                }
            }

            if (tabSwipeConfirmed) {
                // Disable scrolling on tabs during swipe
                tabsContainer.classList.add('tab-swiping');

                // Calculate the new position based on swipe
                const baseOffset = -currentTabIndex * window.innerWidth;
                const newOffset = baseOffset + diffX;

                // Limit swiping at edges
                const minOffset = -(tabIds.length - 1) * window.innerWidth;
                const clampedOffset = Math.max(minOffset, Math.min(0, newOffset));

                tabsTrack.style.transform = `translateX(${clampedOffset}px)`;
            }
        }, { passive: true });

        tabsContainer.addEventListener('touchend', e => {
            tabSwipePending = false;

            // Re-enable scrolling
            tabsContainer.classList.remove('tab-swiping');

            if (!tabSwiping) return;
            tabSwiping = false;

            if (!tabSwipeConfirmed || focusVisible) {
                return;
            }

            const diffX = e.changedTouches[0].clientX - tabSwipeStartX;
            const containerWidth = tabsContainer.offsetWidth;
            const swipeThreshold = containerWidth * 0.2; // 20% of screen

            let newIndex = currentTabIndex;
            if (diffX < -swipeThreshold && currentTabIndex < tabIds.length - 1) {
                newIndex = currentTabIndex + 1;
            } else if (diffX > swipeThreshold && currentTabIndex > 0) {
                newIndex = currentTabIndex - 1;
            }

            switchToTab(newIndex);
        });

        tabsContainer.addEventListener('touchcancel', () => {
            tabsContainer.classList.remove('tab-swiping');
            tabSwiping = false;
            tabSwipePending = false;
            tabSwipeConfirmed = false;
        });

        // ===== BEDTIME MODE =====
        const settingBedtimeStart = document.getElementById('setting-bedtime-start');
        const settingBedtimeEnd = document.getElementById('setting-bedtime-end');
        let isBedtimeMode = false;

        // Load saved bedtime hours
        const savedBedtimeStart = localStorage.getItem('bedtimeStart') || '21';
        const savedBedtimeEnd = localStorage.getItem('bedtimeEnd') || '6';
        settingBedtimeStart.value = savedBedtimeStart;
        settingBedtimeEnd.value = savedBedtimeEnd;

        settingBedtimeStart.addEventListener('change', function() {
            localStorage.setItem('bedtimeStart', this.value);
            localStorage.removeItem('bedtimeManualOverride');
        });

        settingBedtimeEnd.addEventListener('change', function() {
            localStorage.setItem('bedtimeEnd', this.value);
            localStorage.removeItem('bedtimeManualOverride');
        });

        function checkBedtimeTime() {
            const hour = new Date().getHours();
            const start = parseInt(localStorage.getItem('bedtimeStart') || '21');
            const end = parseInt(localStorage.getItem('bedtimeEnd') || '6');
            return hour >= start || hour < end;
        }

        function updateBedtimeIcon(enabled) {
            // Update all bedtime icons across all tabs
            document.querySelectorAll('.tab-top-btn[data-action="bedtime"]').forEach(btn => {
                const moon = btn.querySelector('.icon-moon');
                const sun = btn.querySelector('.icon-sun');
                if (moon) moon.style.display = enabled ? 'none' : 'block';
                if (sun) sun.style.display = enabled ? 'block' : 'none';
            });
        }

        function setBedtimeMode(enabled) {
            isBedtimeMode = enabled;
            document.body.classList.toggle('bedtime-mode', enabled);
            updateBedtimeIcon(enabled);
            localStorage.setItem('bedtimeManualOverride', 'true');
            localStorage.setItem('bedtimeMode', enabled.toString());
        }

        function initBedtimeMode() {
            const manualOverride = localStorage.getItem('bedtimeManualOverride');
            const savedMode = localStorage.getItem('bedtimeMode');
            isBedtimeMode = (manualOverride === 'true' && savedMode !== null)
                ? savedMode === 'true'
                : checkBedtimeTime();
            if (isBedtimeMode) {
                document.body.classList.add('bedtime-mode');
                updateBedtimeIcon(true);
            }
        }

        // Event delegation for tab top buttons (settings + bedtime)
        document.addEventListener('click', e => {
            const btn = e.target.closest('.tab-top-btn');
            if (!btn) return;

            const action = btn.getAttribute('data-action');
            if (action === 'settings') {
                settingsPanel.classList.add('visible');
            } else if (action === 'bedtime') {
                setBedtimeMode(!isBedtimeMode);
            }
        });

        initBedtimeMode();

        // ===== CONFIRMATION MESSAGES =====
        const confirmationMessages = ["Got it.", "Noted.", "Saved.", "Done.", "All yours.", "On the list.", "Won't forget."];
        const bedtimeMessages = ["Captured.", "Got it.", "Noted.", "Set aside.", "For tomorrow."];
        const worryMessages = ["Heard.", "Got it.", "Noted.", "Okay.", "Captured."];

        function getRandomConfirmation(type = 'normal') {
            if (type === 'worry') {
                return worryMessages[Math.floor(Math.random() * worryMessages.length)];
            }
            const messages = isBedtimeMode ? bedtimeMessages : confirmationMessages;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        // ===== DETECTION =====
        function isWorry(text) {
            const lower = text.toLowerCase();
            const worryPatterns = [
                /^what if\b/,
                /\bworried\b/,
                /\bworry\b/,
                /\banxious\b/,
                /\bscared\b/,
                /\bafraid\b/,
                /\bnervous\b/,
                /\bstressed\b/,
                /\boverwhelmed\b/,
                /\bcan't stop thinking\b/,
                /\bkeep thinking\b/,
                /\bwhat if .+\?$/,
                /^i('m| am) (so )?(worried|scared|afraid|anxious|nervous)/,
            ];
            return worryPatterns.some(pattern => pattern.test(lower));
        }

        function isVague(text) {
            const lower = text.toLowerCase();
            const vaguePatterns = [
                /^(figure out|deal with|handle|look into|sort out|work on|think about|address)\b/,
                /\b(figure out|deal with|handle|look into|sort out|work on|think about|address) .+$/,
                /^(do|fix|finish) (the |my |that )?(thing|stuff)\b/,
            ];
            return vaguePatterns.some(pattern => pattern.test(lower));
        }

        // ===== CAPTURE =====
        const input = document.getElementById('thought-input');
        const bigMicButton = document.getElementById('big-mic-button');
        const micContainer = document.getElementById('mic-container');
        const confirmation = document.getElementById('capture-confirmation');

        function haptic(style) {
            if ('vibrate' in navigator) {
                navigator.vibrate(style === 'light' ? 10 : style === 'medium' ? 20 : 30);
            }
        }

        function showConfirmation(message) {
            confirmation.textContent = message || getRandomConfirmation();
            confirmation.classList.add('visible');
            bigMicButton.classList.add('captured');
            setTimeout(() => {
                confirmation.classList.remove('visible');
                bigMicButton.classList.remove('captured');
            }, 2000);
        }

        function captureThought(text) {
            const thought = (text || input.value).trim();
            if (thought === '') return;
            input.value = '';

            // Check if this is a worry (not an actionable task)
            if (isWorry(thought)) {
                worries.push({
                    text: thought,
                    createdAt: Date.now()
                });
                saveAll();
                showConfirmation(getRandomConfirmation('worry'));
                haptic('light');
                return;
            }

            // It's a task - check if vague
            const vague = isVague(thought);
            thoughts.push({
                text: thought,
                skips: 0,
                createdAt: Date.now(),
                isVague: vague
            });

            // If today's focus isn't full, add to it
            const maxFocus = parseInt(localStorage.getItem('dailyFocusItems') || '3');
            if (todayFocus.length < maxFocus) {
                todayFocus.push({ text: thought, skips: 0, createdAt: Date.now(), isVague: vague });
            }

            saveAll();
            showConfirmation();
            haptic('medium');
        }

        input.addEventListener('keydown', e => {
            if (e.key === 'Enter') captureThought();
        });

        // Voice capture
        let recognition = null;
        let isListening = false;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = function(e) {
                recognition.stop();
                captureThought(e.results[0][0].transcript);
            };

            recognition.onend = function() {
                isListening = false;
                bigMicButton.classList.remove('listening');
                micContainer.classList.remove('listening');
                bigMicButton.textContent = 'tap to drop';
            };

            let voiceUnavailable = false;

            recognition.onerror = function(e) {
                console.log('Speech recognition error:', e.error, e);
                isListening = false;
                bigMicButton.classList.remove('listening');
                micContainer.classList.remove('listening');

                if (e.error === 'not-allowed' || e.error === 'service-not-allowed') {
                    // In iOS standalone PWA, speech service is blocked even with mic permission
                    voiceUnavailable = true;
                    bigMicButton.textContent = 'voice unavailable';
                    bigMicButton.style.fontSize = '14px';
                    document.getElementById('text-input-section').style.bottom = '100px';
                    document.getElementById('thought-input').placeholder = 'type here instead';
                } else if (e.error === 'no-speech') {
                    bigMicButton.textContent = 'no speech heard';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to drop';
                    }, 2000);
                } else if (e.error === 'network') {
                    bigMicButton.textContent = 'needs internet';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to drop';
                    }, 2000);
                } else if (e.error === 'audio-capture') {
                    bigMicButton.textContent = 'mic unavailable';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to drop';
                    }, 2000);
                } else {
                    bigMicButton.textContent = e.error || 'error';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to drop';
                    }, 2000);
                }
            };

            async function startListening() {
                // Request mic permission explicitly first (helps with iOS PWA)
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop()); // Release immediately
                } catch (err) {
                    console.log('Mic permission error:', err);
                    bigMicButton.textContent = 'mic blocked';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to drop';
                    }, 2000);
                    return;
                }

                try {
                    recognition.start();
                    isListening = true;
                    bigMicButton.classList.add('listening');
                    micContainer.classList.add('listening');
                    bigMicButton.textContent = 'listening...';
                } catch (err) {
                    console.log('Speech start error:', err);
                    bigMicButton.textContent = 'use text below';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to drop';
                    }, 2000);
                }
            }

            bigMicButton.addEventListener('click', function() {
                if (voiceUnavailable) {
                    // Focus the text input instead
                    document.getElementById('thought-input').focus();
                    return;
                }
                if (isListening) {
                    recognition.stop();
                } else {
                    startListening();
                }
            });
        } else {
            bigMicButton.disabled = true;
            bigMicButton.textContent = 'voice not supported';
        }

        // ===== FOCUS OVERLAY =====
        const focusOverlay = document.getElementById('focus-overlay');
        const focusHandle = document.getElementById('focus-handle');
        const focusContainer = document.getElementById('focus-cards-container');
        const captureTab = document.getElementById('capture-tab');
        let currentCardIndex = 0;

        function openFocusOverlay() {
            focusVisible = true;
            focusOverlay.classList.add('animating');
            focusOverlay.classList.add('visible');
            focusOverlay.style.transform = '';
            renderFocusCards();
            setTimeout(() => focusOverlay.classList.remove('animating'), 300);
        }

        function closeFocusOverlay() {
            focusVisible = false;
            focusOverlay.classList.add('animating');
            focusOverlay.classList.remove('visible');
            focusOverlay.style.transform = '';
            setTimeout(() => focusOverlay.classList.remove('animating'), 300);
        }

        function renderFocusCards() {
            focusContainer.innerHTML = '';

            // Filter out items already handled today
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));

            if (thoughts.length === 0) {
                focusContainer.innerHTML = `
                    <div id="focus-message">
                        <div id="focus-message-title">nothing here yet</div>
                        <div id="focus-message-subtitle">swipe down to add something</div>
                    </div>`;
                return;
            }

            if (remaining.length === 0) {
                const allDone = todayFocus.length > 0 && completedToday.length === todayFocus.length;
                focusContainer.innerHTML = `
                    <div id="focus-message">
                        <div id="focus-message-title">${allDone ? 'all done' : 'all set'}</div>
                        <div id="focus-message-subtitle">${allDone ? "that's everything" : 'see you tomorrow'}</div>
                    </div>`;
                return;
            }

            // Show all remaining cards
            const total = todayFocus.length;
            const completed = completedToday.length;
            remaining.forEach((item, index) => {
                const cardNum = completed + index + 1;
                const wrapper = document.createElement('div');
                wrapper.className = 'focus-card-wrapper';
                wrapper.innerHTML = `
                    <div class="swipe-bg swipe-bg-left">later</div>
                    <div class="swipe-bg swipe-bg-right">done</div>
                    <div class="focus-card">
                        <div class="focus-progress">${cardNum} of ${total}</div>
                        <div class="focus-card-text">${item.text}</div>
                    </div>
                `;
                setupCardSwipe(wrapper, item);
                focusContainer.appendChild(wrapper);
            });
        }

        function setupCardSwipe(wrapper, item) {
            const card = wrapper.querySelector('.focus-card');
            const bgLeft = wrapper.querySelector('.swipe-bg-left');
            const bgRight = wrapper.querySelector('.swipe-bg-right');
            let startX = 0, currentX = 0, swiping = false;

            card.addEventListener('touchstart', e => {
                startX = e.touches[0].clientX;
                currentX = startX;
                swiping = true;
                card.classList.add('swiping');
            }, { passive: true });

            card.addEventListener('touchmove', e => {
                if (!swiping) return;
                currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                card.style.transform = `translateX(${diff}px)`;

                const threshold = 80;
                if (diff > 0) {
                    bgRight.style.opacity = Math.min(1, diff / threshold);
                    bgLeft.style.opacity = 0;
                } else if (diff < 0) {
                    bgLeft.style.opacity = Math.min(1, -diff / threshold);
                    bgRight.style.opacity = 0;
                } else {
                    bgLeft.style.opacity = 0;
                    bgRight.style.opacity = 0;
                }
            }, { passive: true });

            card.addEventListener('touchend', e => {
                if (!swiping) return;
                swiping = false;
                card.classList.remove('swiping');

                const diff = currentX - startX;

                if (diff > 80) {
                    // Swipe right - done
                    card.style.transform = 'translateX(100vw)';
                    haptic('medium');
                    setTimeout(() => {
                        wrapper.classList.add('removing');
                        setTimeout(() => {
                            completedToday.push(item);
                            thoughts = thoughts.filter(t => t.text !== item.text);
                            completedAllTime.push({
                                text: item.text,
                                completedAt: Date.now(),
                                createdAt: item.createdAt
                            });
                            saveAll();
                            renderFocusCards();
                        }, 300);
                    }, 200);
                } else if (diff < -80) {
                    // Swipe left - later
                    card.style.transform = 'translateX(-100vw)';
                    haptic('light');
                    setTimeout(() => {
                        wrapper.classList.add('removing');
                        setTimeout(() => {
                            laterToday.push(item);
                            const idx = thoughts.findIndex(t => t.text === item.text);
                            if (idx > -1) {
                                const t = thoughts.splice(idx, 1)[0];
                                t.skips = (t.skips || 0) + 1;
                                thoughts.push(t);
                            }
                            saveAll();
                            renderFocusCards();
                        }, 300);
                    }, 200);
                } else {
                    // Snap back
                    card.style.transform = '';
                    bgLeft.style.opacity = 0;
                    bgRight.style.opacity = 0;
                }
            });
        }

        // Swipe up on capture tab to open focus overlay
        let captureStartY = 0, captureDragging = false;

        captureTab.addEventListener('touchstart', e => {
            if (focusVisible) return;
            const touch = e.touches[0];
            // Only trigger from bottom half
            if (touch.clientY > window.innerHeight * 0.5) {
                captureStartY = touch.clientY;
                captureDragging = true;
            }
        }, { passive: true });

        captureTab.addEventListener('touchmove', e => {
            if (!captureDragging || focusVisible) return;
            const diff = captureStartY - e.touches[0].clientY;
            if (diff > 10) {
                const progress = Math.min(diff / (window.innerHeight * 0.5), 1);
                focusOverlay.style.transform = `translateY(${(1 - progress) * 100}%)`;
            }
        }, { passive: true });

        captureTab.addEventListener('touchend', e => {
            if (!captureDragging) return;
            captureDragging = false;
            const diff = captureStartY - e.changedTouches[0].clientY;
            if (diff > 100) {
                openFocusOverlay();
            } else {
                focusOverlay.style.transform = '';
            }
        });

        // Swipe down anywhere on focus overlay to close
        let overlayStartY = 0, overlayStartX = 0, overlayDragging = false, overlayDragConfirmed = false;

        focusOverlay.addEventListener('touchstart', e => {
            overlayStartY = e.touches[0].clientY;
            overlayStartX = e.touches[0].clientX;
            overlayDragging = true;
            overlayDragConfirmed = false;
        }, { passive: true });

        focusOverlay.addEventListener('touchmove', e => {
            if (!overlayDragging) return;

            const diffY = e.touches[0].clientY - overlayStartY;
            const diffX = e.touches[0].clientX - overlayStartX;

            // Only handle if vertical swipe is dominant and downward
            if (!overlayDragConfirmed) {
                if (Math.abs(diffX) > 20) {
                    // Horizontal swipe - let card handle it
                    overlayDragging = false;
                    return;
                }
                if (diffY > 20) {
                    overlayDragConfirmed = true;
                }
            }

            if (overlayDragConfirmed && diffY > 0) {
                focusOverlay.style.transform = `translateY(${diffY}px)`;
            }
        }, { passive: true });

        focusOverlay.addEventListener('touchend', e => {
            if (!overlayDragging) return;
            overlayDragging = false;

            if (!overlayDragConfirmed) {
                return;
            }

            const diff = e.changedTouches[0].clientY - overlayStartY;
            if (diff > 100) {
                closeFocusOverlay();
            } else {
                focusOverlay.classList.add('animating');
                focusOverlay.style.transform = '';
                setTimeout(() => focusOverlay.classList.remove('animating'), 300);
            }
        });

        // ===== TODAY TAB =====
        const laterList = document.getElementById('later-list');
        const completedTodayList = document.getElementById('completed-today-list');
        const oldItemsSection = document.getElementById('old-items-section');
        const oldItemsList = document.getElementById('old-items-list');

        function getTimeAgo(timestamp) {
            const days = Math.floor((Date.now() - timestamp) / (1000 * 60 * 60 * 24));
            if (days < 7) return `${days} day${days !== 1 ? 's' : ''} ago`;
            const weeks = Math.floor(days / 7);
            return `${weeks} week${weeks !== 1 ? 's' : ''} ago`;
        }

        function addToTodayFocus(item) {
            // Add to today's focus if not already there
            if (!todayFocus.find(t => t.text === item.text)) {
                todayFocus.push({ ...item });
                saveAll();
                renderTodayTab();
                renderFocusCards();
                haptic('light');
            }
        }

        function renderTodayTab() {
            // Old items (2+ weeks old, not in today's focus)
            const twoWeeksAgo = Date.now() - (14 * 24 * 60 * 60 * 1000);
            const focusTexts = todayFocus.map(t => t.text);
            const oldItems = thoughts
                .filter(t => t.createdAt && t.createdAt < twoWeeksAgo && !focusTexts.includes(t.text))
                .slice(0, 2);

            if (oldItems.length > 0) {
                oldItemsSection.style.display = 'block';
                oldItemsList.innerHTML = '';
                oldItems.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'task-item old tappable';
                    li.innerHTML = `
                        ${item.text}
                        <div class="task-item-age">${getTimeAgo(item.createdAt)}  tap to focus</div>
                    `;
                    li.addEventListener('click', () => addToTodayFocus(item));
                    oldItemsList.appendChild(li);
                });
            } else {
                oldItemsSection.style.display = 'none';
            }

            // For later
            laterList.innerHTML = laterToday.length === 0
                ? '<li class="empty-section">nothing pushed back</li>'
                : laterToday.map(item => `<li class="task-item later">${item.text}</li>`).join('');

            // Completed
            completedTodayList.innerHTML = completedToday.length === 0
                ? '<li class="empty-section"></li>'
                : completedToday.map(item => `<li class="task-item completed">${item.text}</li>`).join('');
        }

        // ===== ALL TAB =====
        const backlogList = document.getElementById('backlog-list');
        let draggedItem = null;
        let draggedIndex = -1;
        let placeholder = null;

        function renderAllTab() {
            // Show thoughts not in today's focus
            const focusTexts = todayFocus.map(t => t.text);
            const backlog = thoughts.filter(t => !focusTexts.includes(t.text));

            if (backlog.length === 0) {
                backlogList.innerHTML = '<div class="empty-section">nothing waiting</div>';
                return;
            }

            backlogList.innerHTML = '';
            backlog.forEach((item, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'backlog-item-wrapper';
                wrapper.dataset.index = index;

                // Build meta info
                let metaHtml = '';
                const metaParts = [];
                if (item.createdAt) {
                    const daysAgo = Math.floor((Date.now() - item.createdAt) / (1000 * 60 * 60 * 24));
                    if (daysAgo === 0) metaParts.push('today');
                    else if (daysAgo === 1) metaParts.push('yesterday');
                    else if (daysAgo < 7) metaParts.push(`${daysAgo} days ago`);
                    else if (daysAgo < 14) metaParts.push('1 week ago');
                    else metaParts.push(`${Math.floor(daysAgo / 7)} weeks ago`);
                }
                if (item.skips > 0) metaParts.push(`deferred ${item.skips}x`);
                if (metaParts.length > 0) {
                    metaHtml = `<div class="backlog-item-meta">${metaParts.map(p => `<span>${p}</span>`).join('')}</div>`;
                }

                wrapper.innerHTML = `
                    <div class="backlog-swipe-bg backlog-swipe-delete">delete</div>
                    <div class="backlog-item">
                        <div class="backlog-item-text">${item.text}</div>
                        ${metaHtml}
                    </div>
                `;
                setupBacklogInteraction(wrapper, item, index, backlog);
                backlogList.appendChild(wrapper);
            });
        }

        function setupBacklogInteraction(wrapper, item, originalIndex, backlog) {
            const itemEl = wrapper.querySelector('.backlog-item');
            const deleteBg = wrapper.querySelector('.backlog-swipe-delete');

            let startX = 0, startY = 0, currentX = 0, currentY = 0;
            let swiping = false, dragging = false, pendingDelete = false;
            let longPressTimer = null;
            let wrapperRect = null;
            let allWrappers = [];
            const LONG_PRESS_DURATION = 400;

            function confirmDelete() {
                itemEl.style.transform = 'translateX(-100vw)';
                haptic('medium');
                setTimeout(() => {
                    wrapper.classList.add('removing');
                    setTimeout(() => {
                        thoughts = thoughts.filter(t => t.text !== item.text);
                        todayFocus = todayFocus.filter(t => t.text !== item.text);
                        saveAll();
                        renderAllTab();
                        renderFocusCards();
                    }, 300);
                }, 150);
            }

            function cancelPendingDelete() {
                pendingDelete = false;
                deleteBg.classList.remove('confirm');
                deleteBg.textContent = 'delete';
                itemEl.style.transform = '';
                deleteBg.style.opacity = 0;
            }

            // Tap on delete background to confirm
            deleteBg.addEventListener('click', e => {
                if (pendingDelete) {
                    e.stopPropagation();
                    confirmDelete();
                }
            });

            function startDragMode(e) {
                dragging = true;
                swiping = false;
                draggedItem = item;
                draggedIndex = originalIndex;

                wrapperRect = wrapper.getBoundingClientRect();
                allWrappers = Array.from(backlogList.querySelectorAll('.backlog-item-wrapper'));

                // Create placeholder
                placeholder = document.createElement('div');
                placeholder.className = 'backlog-placeholder';
                placeholder.style.height = wrapperRect.height + 'px';

                // Style dragged item
                wrapper.classList.add('dragging');
                wrapper.style.position = 'fixed';
                wrapper.style.left = wrapperRect.left + 'px';
                wrapper.style.top = wrapperRect.top + 'px';
                wrapper.style.width = wrapperRect.width + 'px';
                wrapper.style.zIndex = '100';

                // Insert placeholder
                wrapper.parentNode.insertBefore(placeholder, wrapper);
                document.body.appendChild(wrapper);

                haptic('medium');
            }

            itemEl.addEventListener('touchstart', e => {
                // Cancel any pending delete when starting new interaction
                if (pendingDelete) {
                    cancelPendingDelete();
                }

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                currentX = startX;
                currentY = startY;
                swiping = true;
                itemEl.classList.add('swiping');

                // Start long press timer
                longPressTimer = setTimeout(() => {
                    if (swiping && Math.abs(currentX - startX) < 10 && Math.abs(currentY - startY) < 10) {
                        startDragMode(e);
                    }
                }, LONG_PRESS_DURATION);
            }, { passive: true });

            itemEl.addEventListener('touchmove', e => {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;

                // If moved too much, cancel long press
                if (longPressTimer && (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startY) > 10)) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (dragging) {
                    // Drag mode - move vertically
                    const diff = currentY - startY;
                    wrapper.style.top = (wrapperRect.top + diff) + 'px';

                    // Find where to insert placeholder
                    const wrapperCenterY = wrapperRect.top + diff + wrapperRect.height / 2;
                    let insertBefore = null;

                    allWrappers.forEach(w => {
                        if (w === wrapper) return;
                        const rect = w.getBoundingClientRect();
                        if (wrapperCenterY < rect.top + rect.height / 2) {
                            if (!insertBefore || rect.top < insertBefore.getBoundingClientRect().top) {
                                insertBefore = w;
                            }
                        }
                    });

                    // Move placeholder
                    if (insertBefore) {
                        backlogList.insertBefore(placeholder, insertBefore);
                    } else {
                        backlogList.appendChild(placeholder);
                    }
                } else if (swiping) {
                    const diffX = currentX - startX;
                    const diffY = Math.abs(currentY - startY);

                    // If vertical movement is significant or started from edge, this is likely a tab swipe - don't show delete
                    const isTabSwipe = diffY > 20 || startX < 60 || startX > window.innerWidth - 60;

                    // Swipe mode - move horizontally (left only), but not if this looks like a tab swipe
                    if (diffX < 0 && !isTabSwipe) {
                        itemEl.style.transform = `translateX(${diffX}px)`;
                        const opacity = Math.min(1, (-diffX - 30) / 50);
                        deleteBg.style.opacity = Math.max(0, opacity);
                    } else {
                        // Reset if it looks like tab swipe
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                    }
                }
            }, { passive: true });

            itemEl.addEventListener('touchend', e => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (dragging) {
                    // End drag mode
                    dragging = false;

                    // Get new position based on placeholder
                    const newIndex = Array.from(backlogList.children).indexOf(placeholder);

                    // Reset wrapper styling
                    wrapper.classList.remove('dragging');
                    wrapper.style.position = '';
                    wrapper.style.left = '';
                    wrapper.style.top = '';
                    wrapper.style.width = '';
                    wrapper.style.zIndex = '';

                    // Insert at new position
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.insertBefore(wrapper, placeholder);
                        placeholder.remove();
                    }
                    placeholder = null;

                    // Update thoughts array
                    if (newIndex !== -1 && newIndex !== originalIndex) {
                        const focusTexts = todayFocus.map(t => t.text);
                        const backlogItems = thoughts.filter(t => !focusTexts.includes(t.text));
                        const movedItem = backlogItems[originalIndex];

                        // Remove from original position in thoughts
                        const thoughtsIndex = thoughts.findIndex(t => t.text === movedItem.text);
                        if (thoughtsIndex > -1) {
                            thoughts.splice(thoughtsIndex, 1);
                        }

                        // Find insert position in thoughts (after focus items)
                        const focusCount = thoughts.filter(t => focusTexts.includes(t.text)).length;
                        const insertAt = focusCount + newIndex;
                        thoughts.splice(insertAt, 0, movedItem);

                        saveAll();
                        haptic('light');
                    }

                    draggedItem = null;
                    draggedIndex = -1;
                } else if (swiping) {
                    // End swipe mode
                    swiping = false;
                    itemEl.classList.remove('swiping');

                    const diffX = currentX - startX;
                    const diffY = currentY - startY;

                    // Check if this was a tab swipe (started from edge or significant vertical movement)
                    const isTabSwipe = Math.abs(diffY) > 20 || startX < 60 || startX > window.innerWidth - 60;

                    if (diffX < -100 && !isTabSwipe) {
                        // Show delete confirmation
                        pendingDelete = true;
                        const itemWidth = itemEl.offsetWidth;
                        itemEl.style.transform = `translateX(-${itemWidth}px)`;
                        deleteBg.style.opacity = 1;
                        deleteBg.classList.add('confirm');
                        deleteBg.textContent = 'tap to delete';
                        haptic('light');
                    } else if (Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
                        // Simple tap - add to today's focus
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                        addToTodayFocus(item);
                    } else {
                        // Snap back
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                    }
                }
            });

            // Handle touch cancel
            itemEl.addEventListener('touchcancel', () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                swiping = false;
                dragging = false;
                if (pendingDelete) cancelPendingDelete();
                itemEl.classList.remove('swiping');
                wrapper.classList.remove('dragging');
                itemEl.style.transform = '';
                deleteBg.style.opacity = 0;
            });
        }

        // ===== MORNING INTENTION =====
        const morningBanner = document.getElementById('morning-banner');
        const morningFocusList = document.getElementById('morning-focus-list');
        const morningClose = document.getElementById('morning-close');
        const morningAction = document.getElementById('morning-action');

        function isMorningTime() {
            const hour = new Date().getHours();
            return hour >= 6 && hour < 10;
        }

        function showMorningBanner() {
            // Check if already dismissed today
            const dismissedDate = localStorage.getItem('morningDismissed');
            if (dismissedDate === getTodayDate()) return;

            // Check if morning time
            if (!isMorningTime()) return;

            // Check if there are focus items
            if (todayFocus.length === 0) return;

            // Populate focus list
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));

            if (remaining.length === 0) return;

            morningFocusList.innerHTML = remaining.slice(0, 3).map(item =>
                `<div class="morning-focus-preview">${item.text}</div>`
            ).join('');

            morningBanner.classList.add('visible');
        }

        function dismissMorning() {
            morningBanner.classList.remove('visible');
            localStorage.setItem('morningDismissed', getTodayDate());
        }

        morningClose.addEventListener('click', dismissMorning);
        morningAction.addEventListener('click', () => {
            dismissMorning();
            openFocusOverlay();
        });

        // Show morning banner on load
        showMorningBanner();

        // ===== WEEKLY REFLECTION =====
        const weeklyBanner = document.getElementById('weekly-banner');
        const weeklyClose = document.getElementById('weekly-close');
        const weeklyAction = document.getElementById('weekly-action');
        const weeklyCompleted = document.getElementById('weekly-completed');
        const weeklyCaptured = document.getElementById('weekly-captured');

        function getWeekNumber(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            const yearStart = new Date(d.getFullYear(), 0, 1);
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function getWeekKey() {
            const now = new Date();
            return `${now.getFullYear()}-W${getWeekNumber(now)}`;
        }

        function isSundayEvening() {
            const now = new Date();
            return now.getDay() === 0 && now.getHours() >= 17;
        }

        function getWeeklyStats() {
            const now = Date.now();
            const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);

            const completed = completedAllTime.filter(t => t.completedAt && t.completedAt > oneWeekAgo).length;
            const captured = [
                ...thoughts.filter(t => t.createdAt && t.createdAt > oneWeekAgo),
                ...completedAllTime.filter(t => t.createdAt && t.createdAt > oneWeekAgo),
                ...worries.filter(w => w.createdAt && w.createdAt > oneWeekAgo)
            ].length;

            return { completed, captured };
        }

        function showWeeklyBanner() {
            // Check if already reflected this week
            const weekKey = getWeekKey();
            const existingReflection = weeklyReflections.find(r => r.week === weekKey);
            if (existingReflection) return;

            // Check if Sunday evening
            if (!isSundayEvening()) return;

            // Check if dismissed this session
            if (localStorage.getItem('weeklyDismissed') === weekKey) return;

            // Don't show if morning banner is visible
            if (morningBanner.classList.contains('visible')) return;

            const stats = getWeeklyStats();
            if (stats.completed === 0 && stats.captured === 0) return;

            weeklyCompleted.textContent = stats.completed;
            weeklyCaptured.textContent = stats.captured;

            weeklyBanner.classList.add('visible');
        }

        function dismissWeekly() {
            weeklyBanner.classList.remove('visible');
            localStorage.setItem('weeklyDismissed', getWeekKey());
        }

        function saveWeeklyReflection() {
            const stats = getWeeklyStats();
            const weekKey = getWeekKey();

            // Don't save duplicate
            if (weeklyReflections.find(r => r.week === weekKey)) {
                dismissWeekly();
                switchToTab(3); // Go to patterns tab
                return;
            }

            weeklyReflections.unshift({
                week: weekKey,
                date: Date.now(),
                completed: stats.completed,
                captured: stats.captured
            });

            // Keep only last 12 weeks
            weeklyReflections = weeklyReflections.slice(0, 12);

            saveAll();
            dismissWeekly();
            switchToTab(3); // Go to patterns tab
        }

        weeklyClose.addEventListener('click', dismissWeekly);
        weeklyAction.addEventListener('click', saveWeeklyReflection);

        // Show weekly banner on load (after morning check)
        setTimeout(showWeeklyBanner, 100);

        // ===== BACKUP/RESTORE =====
        function updateLastBackupInfo() {
            const lastBackup = localStorage.getItem('lastBackupDate');
            const infoEl = document.getElementById('last-backup-info');
            if (lastBackup) {
                const date = new Date(parseInt(lastBackup));
                const daysAgo = Math.floor((Date.now() - date) / (1000 * 60 * 60 * 24));
                let timeStr;
                if (daysAgo === 0) timeStr = 'today';
                else if (daysAgo === 1) timeStr = 'yesterday';
                else if (daysAgo < 7) timeStr = `${daysAgo} days ago`;
                else timeStr = `${Math.floor(daysAgo / 7)} week${daysAgo >= 14 ? 's' : ''} ago`;
                infoEl.textContent = `Last backup: ${timeStr}`;
                if (daysAgo >= 7) {
                    infoEl.style.color = 'var(--later-color)';
                }
            } else {
                infoEl.textContent = 'No backups yet';
                infoEl.style.color = 'var(--later-color)';
            }
        }

        window.backupToClipboard = async function() {
            const data = {
                thoughts,
                todayFocus,
                laterToday,
                completedToday,
                completedAllTime,
                worries,
                weeklyReflections,
                lastResetDate,
                backupDate: new Date().toISOString(),
                version: 1
            };

            try {
                await navigator.clipboard.writeText(JSON.stringify(data));
                localStorage.setItem('lastBackupDate', Date.now().toString());
                updateLastBackupInfo();
                alert('Backup copied to clipboard! Paste it somewhere safe (Notes, email, etc.)');
            } catch (err) {
                // Fallback for iOS
                const textArea = document.createElement('textarea');
                textArea.value = JSON.stringify(data);
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    localStorage.setItem('lastBackupDate', Date.now().toString());
                    updateLastBackupInfo();
                    alert('Backup copied! Paste it somewhere safe.');
                } catch (e) {
                    alert('Could not copy. Try the Export option in Dev Tools instead.');
                }
                document.body.removeChild(textArea);
            }
        };

        window.restoreFromClipboard = async function() {
            let text;
            try {
                text = await navigator.clipboard.readText();
            } catch (err) {
                text = prompt('Paste your backup data here:');
            }

            if (!text) return;

            try {
                const data = JSON.parse(text);

                // Validate it looks like our data
                if (!data.thoughts || !Array.isArray(data.thoughts)) {
                    alert('Invalid backup data');
                    return;
                }

                if (!confirm(`Restore backup from ${data.backupDate ? new Date(data.backupDate).toLocaleDateString() : 'unknown date'}? This will replace all current data.`)) {
                    return;
                }

                thoughts = data.thoughts || [];
                todayFocus = data.todayFocus || [];
                laterToday = data.laterToday || [];
                completedToday = data.completedToday || [];
                completedAllTime = data.completedAllTime || [];
                worries = data.worries || [];
                weeklyReflections = data.weeklyReflections || [];
                lastResetDate = data.lastResetDate || '';

                saveAll();
                alert('Restored successfully!');
                location.reload();
            } catch (e) {
                alert('Could not parse backup data. Make sure you copied the entire backup.');
            }
        };

        // Update backup info on settings open
        settingsToggle.addEventListener('click', updateLastBackupInfo);

        // ===== DEV TOOLS =====
        window.devGenerateThoughts = function() {
            const sampleThoughts = [
                'Review quarterly goals',
                'Call mom about weekend plans',
                'Research new project management tools',
                'Schedule dentist appointment',
                'Update resume',
                'Clean out garage',
                'Plan team offsite',
                'Read that book everyone recommended',
                'Fix the leaky faucet',
                'Organize photo library'
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            sampleThoughts.forEach((text, i) => {
                const daysAgo = Math.floor(Math.random() * 21) + 1; // 1-21 days ago
                thoughts.push({
                    text,
                    skips: 0,
                    createdAt: now - (daysAgo * dayMs)
                });
            });
            selectTodayFocus();
            saveAll();
            alert('Added 10 sample thoughts');
        };

        window.devGenerateCompleted = function() {
            const sampleCompleted = [
                'Submit expense report',
                'Buy birthday gift',
                'Finish presentation',
                'Reply to emails',
                'Update project status',
                'Review pull request',
                'Book flight tickets',
                'Send meeting notes',
                'Fix bug in login flow',
                'Write blog post draft',
                'Clean desk',
                'Update dependencies',
                'Call insurance company',
                'Prepare demo',
                'Order office supplies'
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            sampleCompleted.forEach((text, i) => {
                const daysAgo = Math.floor(Math.random() * 14); // 0-13 days ago
                completedAllTime.push({
                    text,
                    createdAt: now - ((daysAgo + 1) * dayMs),
                    completedAt: now - (daysAgo * dayMs)
                });
            });
            saveAll();
            alert('Added 15 completed items');
        };

        window.devGenerateWorries = function() {
            const sampleWorries = [
                'What if the project fails?',
                'Worried about the presentation tomorrow',
                'Anxious about the upcoming review',
                'Keep thinking about that awkward conversation',
                'Stressed about deadlines'
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            sampleWorries.forEach((text, i) => {
                const daysAgo = Math.floor(Math.random() * 14);
                worries.push({
                    text,
                    createdAt: now - (daysAgo * dayMs)
                });
            });
            saveAll();
            alert('Added 5 worries');
        };

        window.devGenerateSkipped = function() {
            const skippedItems = [
                { text: 'Organize the basement', skips: 5 },
                { text: 'Start exercising regularly', skips: 4 },
                { text: 'Learn a new language', skips: 3 }
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            skippedItems.forEach(item => {
                thoughts.push({
                    text: item.text,
                    skips: item.skips,
                    createdAt: now - (14 * dayMs)
                });
            });
            selectTodayFocus();
            saveAll();
            alert('Added 3 frequently skipped items');
        };

        window.devGenerateReflections = function() {
            const now = Date.now();
            const weekMs = 7 * 24 * 60 * 60 * 1000;

            for (let i = 1; i <= 4; i++) {
                const weekDate = new Date(now - (i * weekMs));
                const weekNum = getWeekNumber(weekDate);
                const weekKey = `${weekDate.getFullYear()}-W${weekNum}`;

                // Don't duplicate
                if (!weeklyReflections.find(r => r.week === weekKey)) {
                    weeklyReflections.push({
                        week: weekKey,
                        date: weekDate.getTime(),
                        completed: Math.floor(Math.random() * 8) + 2,
                        captured: Math.floor(Math.random() * 12) + 5
                    });
                }
            }
            // Sort by date descending
            weeklyReflections.sort((a, b) => b.date - a.date);
            saveAll();
            alert('Added 4 weeks of reflections');
        };

        window.devTriggerMorning = function() {
            localStorage.removeItem('morningDismissed');
            // Force show
            if (todayFocus.length === 0 && thoughts.length > 0) {
                selectTodayFocus();
                saveAll();
            }
            if (todayFocus.length === 0) {
                alert('Add some thoughts first');
                return;
            }
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));
            if (remaining.length === 0) {
                alert('All focus items already handled today');
                return;
            }
            morningFocusList.innerHTML = remaining.slice(0, 3).map(item =>
                `<div class="morning-focus-preview">${item.text}</div>`
            ).join('');
            morningBanner.classList.add('visible');
            settingsPanel.classList.remove('visible');
        };

        window.devTriggerWeekly = function() {
            localStorage.removeItem('weeklyDismissed');
            const stats = getWeeklyStats();
            if (stats.completed === 0 && stats.captured === 0) {
                alert('Generate some data first');
                return;
            }
            weeklyCompleted.textContent = stats.completed;
            weeklyCaptured.textContent = stats.captured;
            weeklyBanner.classList.add('visible');
            morningBanner.classList.remove('visible');
            settingsPanel.classList.remove('visible');
        };

        window.devExportData = function() {
            const data = {
                thoughts,
                todayFocus,
                laterToday,
                completedToday,
                completedAllTime,
                worries,
                weeklyReflections,
                lastResetDate,
                exportedAt: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `daily-overwhelm-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        };

        window.devClearAllData = function() {
            if (!confirm('This will delete ALL your data. Are you sure?')) return;
            if (!confirm('Really sure? This cannot be undone.')) return;

            thoughts = [];
            todayFocus = [];
            laterToday = [];
            completedToday = [];
            completedAllTime = [];
            worries = [];
            weeklyReflections = [];
            lastResetDate = '';

            localStorage.clear();
            saveAll();

            alert('All data cleared');
            location.reload();
        };

        // ===== SERVICE WORKER =====
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('Service Worker registration failed:', err));
        }

        // Check for daily reset periodically
        setInterval(checkDailyReset, 60000);
    </script>
</body>
</html>
