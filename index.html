<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Daily Overwhelm</title>

    <!-- PWA setup -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Overwhelm">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        * {
            box-sizing: border-box;
        }

        :root {
            --bg-color: #12121f;
            --card-bg: #1e2140;
            --text-color: #eee;
            --text-muted: #999;
            --text-light: #bbb;
            --border-color: #2a2d4a;
            --input-bg: #0f0f1a;
            --shadow: rgba(0,0,0,0.4);
            --accent: #4a90a4;
            --done-color: #5cb85c;
            --later-color: #f0ad4e;
        }

        /* Bedtime mode - warmer, softer colors */
        body.bedtime-mode {
            --bg-color: #141210;
            --card-bg: #2a2520;
            --text-color: #e8dcc8;
            --text-muted: #a09080;
            --text-light: #c8b8a0;
            --border-color: #3a3530;
            --input-bg: #141210;
            --accent: #c4956a;
        }

        body.bedtime-mode #big-mic-button {
            box-shadow: 0 4px 20px rgba(196, 149, 106, 0.3);
        }

        body.bedtime-mode .ripple {
            border-color: var(--accent);
        }

        /* Top buttons */
        #bedtime-toggle, #settings-toggle {
            position: fixed;
            top: 15px;
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            z-index: 50;
            opacity: 0.6;
            transition: opacity 0.2s;
            padding: 8px;
        }

        #bedtime-toggle { right: 15px; }
        #settings-toggle { left: 15px; }

        #bedtime-toggle:hover, #settings-toggle:hover {
            opacity: 1;
        }

        /* Settings panel */
        #settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-color);
            z-index: 200;
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            padding: 20px;
            padding-top: 60px;
        }

        #settings-panel.visible {
            transform: translateX(0);
        }

        #settings-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
        }

        #settings-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 30px;
            color: var(--text-color);
        }

        .settings-section {
            margin-bottom: 30px;
        }

        .settings-section-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 15px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-item-label {
            font-size: 16px;
            color: var(--text-color);
        }

        .settings-item-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .toggle-switch input:disabled + .toggle-slider {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-coming-soon {
            font-size: 11px;
            color: var(--accent);
            margin-left: 10px;
        }

        /* Dev tools */
        .dev-tools-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .dev-tools-warning {
            font-size: 12px;
            color: var(--later-color);
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(240, 173, 78, 0.1);
            border-radius: 8px;
        }

        .dev-button {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 8px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.15s;
        }

        .dev-button:active {
            background-color: var(--border-color);
        }

        .dev-button.danger {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .dev-button-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .dev-subsection {
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--text-muted);
        }

        /* Hide text input in bedtime mode */
        body.bedtime-mode #text-input-section {
            display: none;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        /* Tab content */
        #tabs-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;
        }

        #tabs-track {
            display: flex;
            height: 100%;
            will-change: transform;
        }

        #tabs-track.animating {
            transition: transform 0.3s ease-out;
        }

        .tab-content {
            flex: none;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            width: 100vw;
            min-width: 100vw;
        }

        /* ===== CAPTURE TAB ===== */
        #capture-tab {
            position: relative;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #mic-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #big-mic-button {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background-color: var(--accent);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 4px 20px rgba(74, 144, 164, 0.4);
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
            position: relative;
            z-index: 2;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 0.5px;
            text-transform: lowercase;
        }

        #big-mic-button:active {
            transform: scale(0.98);
        }

        #big-mic-button.listening {
            background-color: #e74c3c;
            box-shadow: 0 4px 30px rgba(231, 76, 60, 0.5);
            animation: pulse-listening 1s infinite;
        }

        .ripple {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 1px solid var(--accent);
            opacity: 0;
            z-index: 1;
            pointer-events: none;
        }

        .ripple-1 { animation: ripple 7s ease-out infinite; }
        .ripple-2 { animation: ripple 7s ease-out infinite 2s; }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 0.4; }
            57% { transform: scale(1.8); opacity: 0; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        @keyframes pulse-listening {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #mic-container.listening .ripple {
            animation: none;
            opacity: 0;
        }

        #capture-confirmation {
            margin-top: 30px;
            padding: 12px 24px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 20px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: 0.3px;
            opacity: 0;
            transform: scale(0.9) translateY(10px);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        #capture-confirmation.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        /* Capture success flash on button */
        #big-mic-button.captured {
            animation: capture-flash 0.4s ease-out;
        }

        @keyframes capture-flash {
            0% { transform: scale(1); }
            30% { transform: scale(0.95); }
            60% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        #text-input-section {
            position: absolute;
            bottom: 80px;
            left: 20px;
            right: 20px;
            max-width: 300px;
            margin: 0 auto;
        }

        #thought-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-color);
            text-align: center;
        }

        #thought-input::placeholder {
            color: var(--text-muted);
        }

        /* Morning intention banner */
        #morning-banner {
            position: absolute;
            top: 60px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a2a4a 0%, #1e3a5a 100%);
            border-radius: 16px;
            padding: 18px 20px;
            border: 1px solid rgba(74, 144, 164, 0.4);
            display: none;
            flex-direction: column;
            gap: 12px;
            animation: morningFadeIn 0.4s ease-out;
            z-index: 10;
        }

        #morning-banner.visible {
            display: flex;
        }

        @keyframes morningFadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .morning-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .morning-greeting {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
        }

        .morning-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .morning-prompt {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .morning-focus-preview {
            font-size: 15px;
            color: var(--text-light);
            padding: 10px 12px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .morning-action {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .morning-action:active {
            opacity: 0.8;
        }

        /* Weekly reflection banner */
        #weekly-banner {
            position: absolute;
            top: 60px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a2a2a 0%, #1e3a30 100%);
            border-radius: 16px;
            padding: 18px 20px;
            border: 1px solid rgba(92, 184, 92, 0.4);
            display: none;
            flex-direction: column;
            gap: 12px;
            animation: morningFadeIn 0.4s ease-out;
            z-index: 10;
        }

        #weekly-banner.visible {
            display: flex;
        }

        .weekly-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .weekly-greeting {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
        }

        .weekly-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .weekly-stats {
            display: flex;
            gap: 16px;
        }

        .weekly-stat {
            flex: 1;
            text-align: center;
            padding: 12px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .weekly-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-color);
        }

        .weekly-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        .weekly-action {
            background-color: var(--done-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .weekly-action:active {
            opacity: 0.8;
        }

        /* Past reflections in patterns tab */
        .reflection-card {
            background-color: var(--card-bg);
            border-radius: 14px;
            padding: 16px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(92, 184, 92, 0.06) 100%);
        }

        .reflection-week {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .reflection-stats {
            display: flex;
            gap: 20px;
        }

        .reflection-stat {
            font-size: 14px;
            color: var(--text-color);
        }

        .reflection-stat span {
            font-weight: 600;
        }

        /* Swipe hint at bottom of capture tab */
        #capture-swipe-hint {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: var(--text-muted);
            opacity: 0.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        #capture-swipe-hint .hint-chevron {
            width: 20px;
            height: 20px;
            opacity: 0.5;
            animation: hint-bounce 2s ease-in-out infinite;
        }

        @keyframes hint-bounce {
            0%, 100% { transform: translateY(0); opacity: 0.5; }
            50% { transform: translateY(-4px); opacity: 0.8; }
        }

        /* ===== FOCUS OVERLAY (swipe up from capture) ===== */
        #focus-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-color);
            z-index: 100;
            transform: translateY(100%);
            display: flex;
            flex-direction: column;
            will-change: transform;
        }

        #focus-overlay.animating {
            transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
        }

        #focus-overlay.visible {
            transform: translateY(0);
        }

        #focus-handle {
            padding: 15px;
            display: flex;
            justify-content: center;
            cursor: grab;
        }

        #focus-handle:active {
            cursor: grabbing;
        }

        .handle-pill {
            width: 36px;
            height: 4px;
            background-color: var(--text-muted);
            border-radius: 2px;
            opacity: 0.4;
        }

        #focus-cards-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 30px;
            gap: 14px;
            overflow: hidden;
        }

        #focus-message {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 20px;
        }

        #focus-message-title {
            font-size: 22px;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 8px;
        }

        #focus-message-subtitle {
            font-size: 15px;
            color: var(--text-muted);
        }

        /* Focus card wrapper */
        .focus-card-wrapper {
            position: relative;
            flex: 1;
            max-height: 140px;
            min-height: 80px;
            border-radius: 12px;
            overflow: hidden;
            transition: flex 0.3s ease-out, opacity 0.3s ease-out, max-height 0.3s ease-out;
        }

        .focus-card-wrapper.removing {
            flex: 0;
            max-height: 0;
            opacity: 0;
            margin: 0;
        }

        /* Swipe backgrounds */
        .swipe-bg {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: lowercase;
            color: white;
            opacity: 0;
            transition: opacity 0.15s;
            border-radius: 12px;
        }

        .swipe-bg-left {
            background: linear-gradient(135deg, var(--later-color), #e09530);
            justify-content: flex-end;
        }

        .swipe-bg-right {
            background: linear-gradient(135deg, #4caf50, var(--done-color));
            justify-content: flex-start;
        }

        /* Focus card */
        .focus-card {
            position: relative;
            height: 100%;
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 18px 20px;
            display: flex;
            align-items: center;
            touch-action: pan-y pinch-zoom;
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .focus-card:active {
            box-shadow: 0 6px 24px rgba(0,0,0,0.2);
        }

        .focus-card.swiping {
            transition: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25);
        }

        .focus-card-text {
            font-size: 16px;
            color: var(--text-color);
            line-height: 1.5;
            flex: 1;
            font-weight: 500;
            position: relative;
            z-index: 1;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .focus-progress {
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 11px;
            color: var(--text-muted);
            opacity: 0.7;
        }

        /* ===== TODAY TAB ===== */
        #today-tab {
            padding-top: 50px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.2px;
            margin-bottom: 12px;
            margin-top: 28px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item {
            padding: 16px 18px;
            background-color: var(--card-bg);
            border-radius: 12px;
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-color);
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .task-item.tappable {
            cursor: pointer;
        }

        .task-item.tappable:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .task-item.later {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(240, 173, 78, 0.08) 100%);
        }

        .task-item.completed {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(92, 184, 92, 0.08) 100%);
            color: var(--text-light);
        }

        .task-item.old {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(150, 150, 150, 0.06) 100%);
            opacity: 0.9;
        }

        .task-item-age {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .empty-section {
            color: var(--text-muted);
            font-size: 14px;
            padding: 20px;
            text-align: center;
            opacity: 0.6;
        }

        /* ===== ALL TAB ===== */
        #all-tab {
            padding-top: 50px;
        }

        /* ===== PATTERNS TAB ===== */
        #patterns-tab {
            padding-top: 50px;
        }

        .patterns-header {
            margin-bottom: 20px;
        }

        .patterns-header-title {
            font-size: 28px;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 4px;
        }

        .patterns-header-subtitle {
            font-size: 14px;
            color: var(--text-muted);
        }

        .pattern-card {
            background-color: var(--card-bg);
            border-radius: 14px;
            padding: 18px;
            margin-bottom: 12px;
            border: 1px solid rgba(255,255,255,0.03);
        }

        .pattern-card.highlight {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(74, 144, 164, 0.12) 100%);
        }

        .pattern-card-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 8px;
        }

        .pattern-card-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-color);
            line-height: 1;
        }

        .pattern-card-detail {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .pattern-row {
            display: flex;
            gap: 12px;
        }

        .pattern-row .pattern-card {
            flex: 1;
        }

        .pattern-bar-container {
            margin-top: 14px;
        }

        .pattern-bar-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .pattern-bar-label {
            width: 36px;
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .pattern-bar-track {
            flex: 1;
            height: 6px;
            background-color: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
        }

        .pattern-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #6bb3c9);
            border-radius: 3px;
            transition: width 0.4s ease-out;
        }

        .pattern-quote {
            font-size: 14px;
            color: var(--text-light);
            line-height: 1.5;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .pattern-quote:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .pattern-quote-skip {
            color: var(--text-muted);
            font-size: 12px;
            margin-left: 8px;
        }

        /* Mini trend chart */
        .pattern-trend {
            display: flex;
            align-items: flex-end;
            gap: 4px;
            height: 40px;
            margin-top: 12px;
        }

        .pattern-trend-bar {
            flex: 1;
            background: linear-gradient(180deg, var(--accent) 0%, rgba(74, 144, 164, 0.4) 100%);
            border-radius: 3px 3px 0 0;
            min-height: 4px;
            transition: height 0.4s ease-out;
        }

        .pattern-trend-bar.empty {
            background: var(--border-color);
        }

        .pattern-trend-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 10px;
            color: var(--text-muted);
        }

        /* Streak display */
        .pattern-streak {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .pattern-streak-flame {
            font-size: 24px;
            line-height: 1;
        }

        .pattern-streak-count {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-color);
        }

        .pattern-streak-label {
            font-size: 13px;
            color: var(--text-muted);
        }

        /* Time of day blocks */
        .pattern-time-blocks {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .pattern-time-block {
            flex: 1;
            text-align: center;
            padding: 10px 6px;
            background-color: var(--input-bg);
            border-radius: 8px;
        }

        .pattern-time-block.active {
            background: linear-gradient(135deg, var(--accent), rgba(74, 144, 164, 0.6));
        }

        .pattern-time-block-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .pattern-time-block.active .pattern-time-block-label {
            color: rgba(255,255,255,0.8);
        }

        .pattern-time-block-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-light);
        }

        .pattern-time-block.active .pattern-time-block-value {
            color: white;
        }

        /* Balance meter */
        .pattern-balance {
            margin-top: 12px;
        }

        .pattern-balance-bar {
            height: 8px;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
        }

        .pattern-balance-captured {
            background: linear-gradient(90deg, #f0ad4e, #e09530);
            transition: width 0.4s ease-out;
        }

        .pattern-balance-completed {
            background: linear-gradient(90deg, #5cb85c, #4caf50);
            transition: width 0.4s ease-out;
        }

        .pattern-balance-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
        }

        .pattern-balance-label {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-muted);
        }

        .pattern-balance-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .pattern-balance-dot.captured {
            background-color: #f0ad4e;
        }

        .pattern-balance-dot.completed {
            background-color: #5cb85c;
        }

        /* Insight card with icon */
        .pattern-insight {
            display: flex;
            align-items: flex-start;
            gap: 14px;
            padding: 14px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .pattern-insight:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .pattern-insight-icon {
            font-size: 20px;
            line-height: 1;
            margin-top: 2px;
        }

        .pattern-insight-text {
            flex: 1;
            font-size: 14px;
            color: var(--text-light);
            line-height: 1.5;
        }

        .pattern-insight-highlight {
            color: var(--text-color);
            font-weight: 600;
        }

        .backlog-item-wrapper {
            position: relative;
            margin-bottom: 10px;
            border-radius: 10px;
            overflow: hidden;
        }

        .backlog-item-wrapper.removing {
            transition: max-height 0.3s, opacity 0.3s, margin 0.3s;
            max-height: 0;
            opacity: 0;
            margin: 0;
            overflow: hidden;
        }

        .backlog-swipe-bg {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 500;
            color: white;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .backlog-swipe-delete {
            background-color: #e74c3c;
            justify-content: flex-end;
        }

        .backlog-swipe-delete.confirm {
            justify-content: center;
            cursor: pointer;
        }

        .backlog-item {
            padding: 16px 18px;
            background-color: var(--card-bg);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            position: relative;
            touch-action: pan-y pinch-zoom;
            transition: transform 0.1s, box-shadow 0.1s;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .backlog-item.swiping {
            transition: none;
        }

        .backlog-item.dragging {
            opacity: 0.9;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 10;
            transform: scale(1.02);
        }

        .backlog-item-text {
            font-size: 15px;
            line-height: 1.4;
            color: var(--text-color);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .backlog-item-meta {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            gap: 12px;
        }

        .backlog-item-meta span {
            opacity: 0.8;
        }

        .backlog-placeholder {
            background-color: var(--border-color);
            border-radius: 10px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* ===== TAB BAR ===== */
        #tab-bar {
            display: flex;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            padding-bottom: max(8px, env(safe-area-inset-bottom));
        }

        .tab-button {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 11px;
            padding: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .tab-button svg {
            width: 22px;
            height: 22px;
        }

        .tab-button.active {
            color: var(--accent);
        }

        /* Icon button styling */
        #settings-toggle svg,
        #bedtime-toggle svg,
        #settings-close svg {
            display: block;
        }
    </style>
</head>
<body>
    <!-- SETTINGS TOGGLE -->
    <button id="settings-toggle" title="Settings">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </button>

    <!-- BEDTIME TOGGLE -->
    <button id="bedtime-toggle" title="Toggle bedtime mode">
        <svg class="icon-moon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
        <svg class="icon-sun" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
    </button>

    <!-- SETTINGS PANEL -->
    <div id="settings-panel">
        <button id="settings-close">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <div id="settings-title">settings</div>

        <div class="settings-section">
            <div class="settings-section-title">Notifications</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Bedtime reminder<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Prompt to capture thoughts before sleep</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-bedtime-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Morning focus<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Daily reminder of your focus items</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-morning-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Periodic reminders<span class="settings-coming-soon">coming soon</span></div>
                    <div class="settings-item-desc">Gentle nudges throughout the day</div>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-periodic-notif" disabled>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Display</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Daily focus items</div>
                    <div class="settings-item-desc">How many tasks to show each day</div>
                </div>
                <select id="setting-daily-items" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="5">5</option>
                </select>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Bedtime Mode</div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Starts at</div>
                    <div class="settings-item-desc">When bedtime mode activates</div>
                </div>
                <select id="setting-bedtime-start" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="20">8 pm</option>
                    <option value="21" selected>9 pm</option>
                    <option value="22">10 pm</option>
                    <option value="23">11 pm</option>
                </select>
            </div>

            <div class="settings-item">
                <div>
                    <div class="settings-item-label">Ends at</div>
                    <div class="settings-item-desc">When bedtime mode turns off</div>
                </div>
                <select id="setting-bedtime-end" style="padding: 8px 12px; font-size: 16px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 8px;">
                    <option value="5">5 am</option>
                    <option value="6" selected>6 am</option>
                    <option value="7">7 am</option>
                    <option value="8">8 am</option>
                </select>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-section-title">Backup</div>
            <div class="settings-item-desc" style="margin-bottom: 15px;">Your data is stored locally. Back up regularly to avoid losing it.</div>

            <button class="dev-button" onclick="backupToClipboard()" style="margin-bottom: 8px;">
                Copy Backup to Clipboard
                <div class="dev-button-desc">Quick backup - paste into Notes or anywhere</div>
            </button>
            <button class="dev-button" onclick="restoreFromClipboard()">
                Restore from Clipboard
                <div class="dev-button-desc">Paste a previous backup to restore</div>
            </button>
            <div id="last-backup-info" style="font-size: 12px; color: var(--text-muted); margin-top: 12px; text-align: center;"></div>
        </div>

        <!-- Dev Tools Section -->
        <div class="dev-tools-section">
            <div class="settings-section-title">Dev Tools</div>
            <div class="dev-tools-warning">Testing only. Changes affect your real data.</div>

            <div class="dev-subsection">Generate Sample Data</div>
            <button class="dev-button" onclick="devGenerateThoughts()">
                Generate Sample Thoughts
                <div class="dev-button-desc">Add 10 thoughts with varied ages (1 day to 3 weeks old)</div>
            </button>
            <button class="dev-button" onclick="devGenerateCompleted()">
                Generate Completed Items
                <div class="dev-button-desc">Add 15 completed items over past 2 weeks</div>
            </button>
            <button class="dev-button" onclick="devGenerateWorries()">
                Generate Worries
                <div class="dev-button-desc">Add 5 sample worries</div>
            </button>
            <button class="dev-button" onclick="devGenerateSkipped()">
                Generate Skipped Items
                <div class="dev-button-desc">Add items with high skip counts</div>
            </button>
            <button class="dev-button" onclick="devGenerateReflections()">
                Generate Weekly Reflections
                <div class="dev-button-desc">Add 4 weeks of reflection history</div>
            </button>

            <div class="dev-subsection">Triggers</div>
            <button class="dev-button" onclick="devTriggerMorning()">
                Show Morning Banner Now
                <div class="dev-button-desc">Force show regardless of time</div>
            </button>
            <button class="dev-button" onclick="devTriggerWeekly()">
                Show Weekly Banner Now
                <div class="dev-button-desc">Force show regardless of day/time</div>
            </button>

            <div class="dev-subsection">Data Management</div>
            <button class="dev-button" onclick="devExportData()">
                Export All Data
                <div class="dev-button-desc">Download as JSON file</div>
            </button>
            <button class="dev-button danger" onclick="devClearAllData()">
                Clear All Data
                <div class="dev-button-desc">Remove all thoughts, completions, and reflections</div>
            </button>
        </div>

    </div>

    <!-- TABS -->
    <div id="tabs-container">
        <div id="tabs-track">
            <!-- CAPTURE TAB -->
            <div id="capture-tab" class="tab-content">
                <!-- Morning intention banner -->
                <div id="morning-banner">
                    <div class="morning-header">
                        <div class="morning-greeting">good morning</div>
                        <button class="morning-close" id="morning-close">&times;</button>
                    </div>
                    <div class="morning-prompt">here's what's on your plate today:</div>
                    <div id="morning-focus-list"></div>
                    <button class="morning-action" id="morning-action">let's do this</button>
                </div>

                <!-- Weekly reflection banner -->
                <div id="weekly-banner">
                    <div class="weekly-header">
                        <div class="weekly-greeting">week in review</div>
                        <button class="weekly-close" id="weekly-close">&times;</button>
                    </div>
                    <div class="weekly-stats">
                        <div class="weekly-stat">
                            <div class="weekly-stat-value" id="weekly-completed">0</div>
                            <div class="weekly-stat-label">completed</div>
                        </div>
                        <div class="weekly-stat">
                            <div class="weekly-stat-value" id="weekly-captured">0</div>
                            <div class="weekly-stat-label">captured</div>
                        </div>
                    </div>
                    <button class="weekly-action" id="weekly-action">save & view patterns</button>
                </div>

                <div id="mic-container">
                    <div class="ripple ripple-1"></div>
                    <div class="ripple ripple-2"></div>
                    <button id="big-mic-button">tap to capture</button>
                </div>
                <div id="capture-confirmation"></div>
                <div id="text-input-section">
                    <input type="text" id="thought-input" placeholder="or type here">
                </div>
                <div id="capture-swipe-hint">
                    <svg class="hint-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="18 15 12 9 6 15"></polyline>
                    </svg>
                    <span>today's focus</span>
                </div>
            </div>

            <!-- TODAY TAB -->
            <div id="today-tab" class="tab-content">
                <div id="old-items-section" style="display: none;">
                    <div class="section-title">been on your mind</div>
                    <ul id="old-items-list" class="task-list"></ul>
                </div>

                <div class="section-title">for later</div>
                <ul id="later-list" class="task-list"></ul>

                <div class="section-title">done</div>
                <ul id="completed-today-list" class="task-list"></ul>
            </div>

            <!-- ALL TAB -->
            <div id="all-tab" class="tab-content">
                <div class="section-title">backlog</div>
                <div id="backlog-list"></div>
            </div>

            <!-- PATTERNS TAB -->
            <div id="patterns-tab" class="tab-content">
                <div class="section-title">patterns</div>
                <div id="patterns-container"></div>
            </div>
        </div>
    </div>

    <!-- FOCUS OVERLAY -->
    <div id="focus-overlay">
        <div id="focus-handle">
            <div class="handle-pill"></div>
        </div>
        <div id="focus-cards-container">
            <!-- Cards or message will be rendered here -->
        </div>
    </div>

    <!-- TAB BAR -->
    <div id="tab-bar">
        <button class="tab-button active" data-tab="capture-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
            <span>Capture</span>
        </button>
        <button class="tab-button" data-tab="today-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="6"></circle>
                <circle cx="12" cy="12" r="2"></circle>
            </svg>
            <span>Today</span>
        </button>
        <button class="tab-button" data-tab="all-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="8" y1="6" x2="21" y2="6"></line>
                <line x1="8" y1="12" x2="21" y2="12"></line>
                <line x1="8" y1="18" x2="21" y2="18"></line>
                <line x1="3" y1="6" x2="3.01" y2="6"></line>
                <line x1="3" y1="12" x2="3.01" y2="12"></line>
                <line x1="3" y1="18" x2="3.01" y2="18"></line>
            </svg>
            <span>All</span>
        </button>
        <button class="tab-button" data-tab="patterns-tab">
            <svg class="tab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="20" x2="18" y2="10"></line>
                <line x1="12" y1="20" x2="12" y2="4"></line>
                <line x1="6" y1="20" x2="6" y2="14"></line>
            </svg>
            <span>Patterns</span>
        </button>
    </div>

    <script>
        // ===== DATA MODEL =====
        let thoughts = JSON.parse(localStorage.getItem('thoughts')) || [];
        let todayFocus = JSON.parse(localStorage.getItem('todayFocus')) || [];
        let laterToday = JSON.parse(localStorage.getItem('laterToday')) || [];
        let completedToday = JSON.parse(localStorage.getItem('completedToday')) || [];
        let completedAllTime = JSON.parse(localStorage.getItem('completedAllTime')) || [];
        let worries = JSON.parse(localStorage.getItem('worries')) || [];
        let weeklyReflections = JSON.parse(localStorage.getItem('weeklyReflections')) || [];
        let lastResetDate = localStorage.getItem('lastResetDate') || '';

        // Migrate old formats
        thoughts = thoughts.map(item => {
            if (typeof item === 'string') {
                return { text: item, skips: 0, createdAt: Date.now() };
            }
            if (!item.createdAt) {
                item.createdAt = Date.now();
            }
            return item;
        });

        // Migrate completedAllTime from strings to objects
        completedAllTime = completedAllTime.map(item => {
            if (typeof item === 'string') {
                return { text: item, completedAt: Date.now() };
            }
            return item;
        });

        function saveAll() {
            localStorage.setItem('thoughts', JSON.stringify(thoughts));
            localStorage.setItem('todayFocus', JSON.stringify(todayFocus));
            localStorage.setItem('laterToday', JSON.stringify(laterToday));
            localStorage.setItem('completedToday', JSON.stringify(completedToday));
            localStorage.setItem('completedAllTime', JSON.stringify(completedAllTime));
            localStorage.setItem('worries', JSON.stringify(worries));
            localStorage.setItem('weeklyReflections', JSON.stringify(weeklyReflections));
            localStorage.setItem('lastResetDate', lastResetDate);
        }

        function getTodayDate() {
            return new Date().toDateString();
        }

        function checkDailyReset() {
            const today = getTodayDate();
            if (lastResetDate !== today) {
                // New day - reset
                laterToday = [];
                completedToday = [];
                lastResetDate = today;
                selectTodayFocus();
                saveAll();
            }
        }

        function selectTodayFocus() {
            const count = parseInt(localStorage.getItem('dailyFocusItems') || '3');
            todayFocus = thoughts.slice(0, count).map(t => ({ ...t }));
        }

        // Initialize on load
        checkDailyReset();
        if (todayFocus.length === 0 && thoughts.length > 0) {
            selectTodayFocus();
            saveAll();
        }

        // Track focus overlay state (used by tab swiping)
        let focusVisible = false;

        // ===== SETTINGS =====
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsClose = document.getElementById('settings-close');
        const settingDailyItems = document.getElementById('setting-daily-items');

        settingsToggle.addEventListener('click', () => settingsPanel.classList.add('visible'));
        settingsClose.addEventListener('click', () => settingsPanel.classList.remove('visible'));

        const savedDailyItems = localStorage.getItem('dailyFocusItems') || '3';
        settingDailyItems.value = savedDailyItems;

        settingDailyItems.addEventListener('change', function() {
            localStorage.setItem('dailyFocusItems', this.value);
            selectTodayFocus();
            saveAll();
            renderFocusCards();
        });

        // ===== PATTERNS =====
        function renderPatterns() {
            const container = document.getElementById('patterns-container');
            const now = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;
            const oneWeekAgo = now - (7 * oneDay);
            const twoWeeksAgo = now - (14 * oneDay);

            // Calculate basic stats
            const totalCapturedTasks = thoughts.length + completedAllTime.length;
            const totalCaptured = totalCapturedTasks + worries.length;
            const totalCompleted = completedAllTime.length;
            const thisWeekCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > oneWeekAgo).length;
            const lastWeekCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > twoWeeksAgo && t.completedAt <= oneWeekAgo).length;
            const backlogSize = thoughts.length;
            const worriesReleased = worries.length;

            // Not enough data
            if (totalCaptured < 3) {
                container.innerHTML = '<div class="empty-section">capture a few more thoughts to see patterns</div>';
                return;
            }

            let html = '';

            // ========== TOP ROW: Key Numbers ==========
            html += '<div class="pattern-row">';
            html += `<div class="pattern-card highlight">
                <div class="pattern-card-label">completed</div>
                <div class="pattern-card-value">${totalCompleted}</div>
                <div class="pattern-card-detail">all time</div>
            </div>`;
            html += `<div class="pattern-card">
                <div class="pattern-card-label">waiting</div>
                <div class="pattern-card-value">${backlogSize}</div>
                <div class="pattern-card-detail">in backlog</div>
            </div>`;
            html += '</div>';

            // ========== COMPLETION RATE ==========
            if (totalCapturedTasks > 0) {
                const completionRate = Math.round((totalCompleted / totalCapturedTasks) * 100);
                let rateDetail = '';
                if (completionRate >= 70) rateDetail = 'excellent follow-through';
                else if (completionRate >= 50) rateDetail = 'good progress';
                else if (completionRate >= 30) rateDetail = 'building momentum';
                else rateDetail = 'room to grow';

                html += `<div class="pattern-card${completionRate >= 50 ? ' highlight' : ''}">
                    <div class="pattern-card-label">completion rate</div>
                    <div class="pattern-card-value">${completionRate}%</div>
                    <div class="pattern-card-detail">${rateDetail}</div>
                </div>`;
            }

            // ========== WEEKLY TREND CHART ==========
            const weeklyData = [];
            for (let i = 7; i >= 0; i--) {
                const weekStart = now - ((i + 1) * 7 * oneDay);
                const weekEnd = now - (i * 7 * oneDay);
                const count = completedAllTime.filter(t =>
                    t.completedAt && t.completedAt > weekStart && t.completedAt <= weekEnd
                ).length;
                weeklyData.push(count);
            }
            const maxWeekly = Math.max(...weeklyData, 1);

            if (weeklyData.some(w => w > 0)) {
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">weekly completions</div>
                    <div class="pattern-trend">`;
                weeklyData.forEach(count => {
                    const height = Math.max(4, Math.round((count / maxWeekly) * 40));
                    html += `<div class="pattern-trend-bar${count === 0 ? ' empty' : ''}" style="height: ${height}px" title="${count}"></div>`;
                });
                html += `</div>
                    <div class="pattern-trend-labels">
                        <span>8 weeks ago</span>
                        <span>this week</span>
                    </div>
                </div>`;
            }

            // ========== THIS WEEK VS LAST WEEK ==========
            if (thisWeekCompleted > 0 || lastWeekCompleted > 0) {
                let velocityDetail = '';
                let highlight = false;
                if (lastWeekCompleted > 0 && thisWeekCompleted > lastWeekCompleted) {
                    const pctUp = Math.round(((thisWeekCompleted - lastWeekCompleted) / lastWeekCompleted) * 100);
                    velocityDetail = `+${pctUp}% from last week`;
                    highlight = true;
                } else if (lastWeekCompleted > 0 && thisWeekCompleted < lastWeekCompleted) {
                    velocityDetail = `down from ${lastWeekCompleted} last week`;
                } else if (lastWeekCompleted > 0) {
                    velocityDetail = `same as last week`;
                } else {
                    velocityDetail = 'this week';
                }
                html += `<div class="pattern-card${highlight ? ' highlight' : ''}">
                    <div class="pattern-card-label">this week</div>
                    <div class="pattern-card-value">${thisWeekCompleted}</div>
                    <div class="pattern-card-detail">${velocityDetail}</div>
                </div>`;
            }

            // ========== COMPLETION STREAK ==========
            let currentStreak = 0;
            let checkDate = new Date();
            checkDate.setHours(0, 0, 0, 0);

            // Check if completed something today
            const todayStart = checkDate.getTime();
            const todayEnd = todayStart + oneDay;
            const completedToday = completedAllTime.some(t =>
                t.completedAt && t.completedAt >= todayStart && t.completedAt < todayEnd
            );

            // If nothing today, start checking from yesterday
            if (!completedToday) {
                checkDate.setDate(checkDate.getDate() - 1);
            }

            // Count consecutive days with completions
            while (true) {
                const dayStart = checkDate.getTime();
                const dayEnd = dayStart + oneDay;
                const hasCompletion = completedAllTime.some(t =>
                    t.completedAt && t.completedAt >= dayStart && t.completedAt < dayEnd
                );
                if (hasCompletion) {
                    currentStreak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                } else {
                    break;
                }
                if (currentStreak > 365) break; // Safety limit
            }

            if (currentStreak >= 2) {
                html += `<div class="pattern-card highlight">
                    <div class="pattern-card-label">current streak</div>
                    <div class="pattern-streak">
                        <span class="pattern-streak-flame"></span>
                        <span class="pattern-streak-count">${currentStreak}</span>
                        <span class="pattern-streak-label">days in a row</span>
                    </div>
                </div>`;
            }

            // ========== AVERAGE TIME TO COMPLETION ==========
            const completedWithTimes = completedAllTime.filter(t => t.createdAt && t.completedAt);
            if (completedWithTimes.length >= 3) {
                const avgMs = completedWithTimes.reduce((sum, t) => sum + (t.completedAt - t.createdAt), 0) / completedWithTimes.length;
                const avgDays = avgMs / oneDay;

                let avgText, avgDetail;
                if (avgDays < 1) {
                    const avgHours = Math.round(avgMs / (60 * 60 * 1000));
                    avgText = avgHours <= 1 ? '<1 hr' : `${avgHours} hrs`;
                    avgDetail = 'quick turnaround';
                } else if (avgDays < 7) {
                    avgText = `${Math.round(avgDays)} days`;
                    avgDetail = avgDays <= 2 ? 'fast execution' : 'steady pace';
                } else {
                    const weeks = Math.round(avgDays / 7);
                    avgText = `${weeks} week${weeks > 1 ? 's' : ''}`;
                    avgDetail = 'thoughtful approach';
                }

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">avg time to done</div>
                    <div class="pattern-card-value">${avgText}</div>
                    <div class="pattern-card-detail">${avgDetail}</div>
                </div>`;
            }

            // ========== TIME OF DAY ACTIVITY ==========
            const completionTimestamps = completedAllTime.map(t => t.completedAt).filter(Boolean);
            if (completionTimestamps.length >= 5) {
                const timeBlocks = { morning: 0, afternoon: 0, evening: 0, night: 0 };
                completionTimestamps.forEach(ts => {
                    const hour = new Date(ts).getHours();
                    if (hour >= 5 && hour < 12) timeBlocks.morning++;
                    else if (hour >= 12 && hour < 17) timeBlocks.afternoon++;
                    else if (hour >= 17 && hour < 21) timeBlocks.evening++;
                    else timeBlocks.night++;
                });

                const maxBlock = Math.max(...Object.values(timeBlocks));
                const activeBlock = Object.entries(timeBlocks).find(([_, v]) => v === maxBlock)?.[0];

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">when you get things done</div>
                    <div class="pattern-time-blocks">
                        <div class="pattern-time-block${activeBlock === 'morning' ? ' active' : ''}">
                            <div class="pattern-time-block-label">morning</div>
                            <div class="pattern-time-block-value">${timeBlocks.morning}</div>
                        </div>
                        <div class="pattern-time-block${activeBlock === 'afternoon' ? ' active' : ''}">
                            <div class="pattern-time-block-label">afternoon</div>
                            <div class="pattern-time-block-value">${timeBlocks.afternoon}</div>
                        </div>
                        <div class="pattern-time-block${activeBlock === 'evening' ? ' active' : ''}">
                            <div class="pattern-time-block-label">evening</div>
                            <div class="pattern-time-block-value">${timeBlocks.evening}</div>
                        </div>
                        <div class="pattern-time-block${activeBlock === 'night' ? ' active' : ''}">
                            <div class="pattern-time-block-label">night</div>
                            <div class="pattern-time-block-value">${timeBlocks.night}</div>
                        </div>
                    </div>
                </div>`;
            }

            // ========== MOST PRODUCTIVE DAY ==========
            const completionDayCounts = [0, 0, 0, 0, 0, 0, 0]; // Sun-Sat
            completedAllTime.forEach(t => {
                if (t.completedAt) {
                    completionDayCounts[new Date(t.completedAt).getDay()]++;
                }
            });
            const maxDayCount = Math.max(...completionDayCounts);
            if (maxDayCount >= 2) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const mostProductiveDay = completionDayCounts.indexOf(maxDayCount);
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">most productive day</div>
                    <div class="pattern-card-value">${dayNames[mostProductiveDay]}</div>
                    <div class="pattern-card-detail">${maxDayCount} completions total</div>
                </div>`;
            }

            // ========== CAPTURE VS COMPLETE BALANCE ==========
            const recentCaptured = [
                ...thoughts.filter(t => t.createdAt && t.createdAt > twoWeeksAgo),
                ...completedAllTime.filter(t => t.createdAt && t.createdAt > twoWeeksAgo)
            ].length;
            const recentCompleted = completedAllTime.filter(t => t.completedAt && t.completedAt > twoWeeksAgo).length;

            if (recentCaptured > 0 || recentCompleted > 0) {
                const total = recentCaptured + recentCompleted;
                const capturedPct = Math.round((recentCaptured / total) * 100);
                const completedPct = 100 - capturedPct;

                let balanceInsight = '';
                if (recentCompleted > recentCaptured) {
                    balanceInsight = 'clearing more than adding - nice!';
                } else if (recentCaptured > recentCompleted * 2) {
                    balanceInsight = 'lots of new ideas flowing';
                } else {
                    balanceInsight = 'healthy balance';
                }

                html += `<div class="pattern-card">
                    <div class="pattern-card-label">last 2 weeks</div>
                    <div class="pattern-balance">
                        <div class="pattern-balance-bar">
                            <div class="pattern-balance-captured" style="width: ${capturedPct}%"></div>
                            <div class="pattern-balance-completed" style="width: ${completedPct}%"></div>
                        </div>
                        <div class="pattern-balance-labels">
                            <div class="pattern-balance-label">
                                <span class="pattern-balance-dot captured"></span>
                                ${recentCaptured} captured
                            </div>
                            <div class="pattern-balance-label">
                                <span class="pattern-balance-dot completed"></span>
                                ${recentCompleted} completed
                            </div>
                        </div>
                    </div>
                    <div class="pattern-card-detail" style="margin-top: 10px;">${balanceInsight}</div>
                </div>`;
            }

            // ========== OLDEST ITEM ==========
            const thoughtsWithDates = thoughts.filter(t => t.createdAt);
            if (thoughtsWithDates.length > 0) {
                const oldest = thoughtsWithDates.reduce((a, b) => a.createdAt < b.createdAt ? a : b);
                const daysOld = Math.floor((now - oldest.createdAt) / oneDay);
                if (daysOld >= 3) {
                    const truncated = oldest.text.length > 40 ? oldest.text.slice(0, 40) + '...' : oldest.text;
                    const timeStr = daysOld >= 14 ? `${Math.floor(daysOld / 7)} weeks` : `${daysOld} days`;
                    html += `<div class="pattern-card">
                        <div class="pattern-card-label">oldest in backlog</div>
                        <div class="pattern-quote">"${truncated}"</div>
                        <div class="pattern-card-detail">${timeStr} old</div>
                    </div>`;
                }
            }

            // ========== FREQUENTLY DEFERRED ==========
            const frequentlySkipped = thoughts.filter(t => t.skips >= 2).sort((a, b) => b.skips - a.skips);
            if (frequentlySkipped.length > 0) {
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">keeps getting pushed back</div>`;
                frequentlySkipped.slice(0, 3).forEach(item => {
                    const truncated = item.text.length > 35 ? item.text.slice(0, 35) + '...' : item.text;
                    html += `<div class="pattern-quote">"${truncated}"<span class="pattern-quote-skip">${item.skips}x</span></div>`;
                });
                html += '</div>';
            }

            // ========== WORRIES RELEASED ==========
            if (worriesReleased > 0) {
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">worries released</div>
                    <div class="pattern-card-value">${worriesReleased}</div>
                    <div class="pattern-card-detail">captured and let go</div>
                </div>`;
            }

            // ========== PERSONALIZED INSIGHTS ==========
            const insights = [];

            // Fast completer insight
            if (completedWithTimes.length >= 3) {
                const avgDays = completedWithTimes.reduce((sum, t) => sum + (t.completedAt - t.createdAt), 0) / completedWithTimes.length / oneDay;
                if (avgDays < 2) {
                    insights.push({ icon: '', text: `You're a <span class="pattern-insight-highlight">fast executor</span> - most items done within ${Math.round(avgDays * 24)} hours of capture.` });
                }
            }

            // Weekend warrior insight
            const weekendCompletions = completionDayCounts[0] + completionDayCounts[6];
            const weekdayCompletions = completionDayCounts.slice(1, 6).reduce((a, b) => a + b, 0);
            if (weekendCompletions > weekdayCompletions && weekendCompletions >= 3) {
                insights.push({ icon: '', text: `You're a <span class="pattern-insight-highlight">weekend warrior</span> - you get more done on Sat/Sun than weekdays.` });
            }

            // Morning person insight
            if (completionTimestamps.length >= 5) {
                const morningCount = completionTimestamps.filter(ts => {
                    const h = new Date(ts).getHours();
                    return h >= 5 && h < 12;
                }).length;
                if (morningCount > completionTimestamps.length * 0.5) {
                    insights.push({ icon: '', text: `You're a <span class="pattern-insight-highlight">morning person</span> - most of your completions happen before noon.` });
                }
            }

            // Night owl insight
            if (completionTimestamps.length >= 5) {
                const nightCount = completionTimestamps.filter(ts => {
                    const h = new Date(ts).getHours();
                    return h >= 21 || h < 5;
                }).length;
                if (nightCount > completionTimestamps.length * 0.3) {
                    insights.push({ icon: '', text: `You're a <span class="pattern-insight-highlight">night owl</span> - you often get things done late at night.` });
                }
            }

            // Streak milestone
            if (currentStreak >= 7) {
                insights.push({ icon: '', text: `<span class="pattern-insight-highlight">${currentStreak} day streak!</span> You've been consistently completing tasks for over a week.` });
            }

            // Backlog clearer
            if (totalCompleted > backlogSize * 2 && totalCompleted >= 10) {
                insights.push({ icon: '', text: `You've completed <span class="pattern-insight-highlight">${totalCompleted} items</span> - more than double your current backlog. Great execution!` });
            }

            if (insights.length > 0) {
                html += `<div class="pattern-card">
                    <div class="pattern-card-label">insights about you</div>`;
                insights.slice(0, 3).forEach(insight => {
                    html += `<div class="pattern-insight">
                        <span class="pattern-insight-icon">${insight.icon}</span>
                        <span class="pattern-insight-text">${insight.text}</span>
                    </div>`;
                });
                html += '</div>';
            }

            // ========== WEEKLY REFLECTIONS ==========
            if (weeklyReflections.length > 0) {
                html += `<div class="section-title" style="margin-top: 24px;">weekly reflections</div>`;
                weeklyReflections.forEach(reflection => {
                    const date = new Date(reflection.date);
                    const weekLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    html += `<div class="reflection-card">
                        <div class="reflection-week">Week of ${weekLabel}</div>
                        <div class="reflection-stats">
                            <div class="reflection-stat"><span>${reflection.completed}</span> completed</div>
                            <div class="reflection-stat"><span>${reflection.captured}</span> captured</div>
                        </div>
                    </div>`;
                });
            }

            container.innerHTML = html;
        }

        // ===== TAB SWITCHING =====
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabsTrack = document.getElementById('tabs-track');
        const tabIds = ['capture-tab', 'today-tab', 'all-tab', 'patterns-tab'];
        let currentTabIndex = 0;

        function switchToTab(index, animate = true) {
            if (index < 0 || index >= tabIds.length) return;
            currentTabIndex = index;

            tabButtons.forEach(b => b.classList.remove('active'));
            tabButtons[index].classList.add('active');

            if (animate) {
                tabsTrack.classList.add('animating');
            }
            tabsTrack.style.transform = `translateX(${-index * 100}vw)`;

            if (animate) {
                setTimeout(() => tabsTrack.classList.remove('animating'), 300);
            }

            if (tabIds[index] === 'today-tab') renderTodayTab();
            if (tabIds[index] === 'all-tab') renderAllTab();
            if (tabIds[index] === 'patterns-tab') renderPatterns();
        }

        tabButtons.forEach((btn, index) => {
            btn.addEventListener('click', function() {
                switchToTab(index);
            });
        });

        // Swipe between tabs
        let tabSwipeStartX = 0;
        let tabSwipeStartY = 0;
        let tabSwipeStartTime = 0;
        let tabSwiping = false;
        let tabSwipeConfirmed = false;
        let tabSwipePending = false; // Started on card, but might become tab swipe
        let cardSwipeInProgress = false; // Global flag for card swipes

        const tabsContainer = document.getElementById('tabs-container');

        tabsContainer.addEventListener('touchstart', e => {
            // Don't start tab swipe if focus overlay is open
            if (focusVisible) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const edgeThreshold = 60; // pixels from screen edge
            const topZone = 120; // pixels from top where tab swipe always works
            const bottomZone = 80; // pixels from bottom where tab swipe always works

            // Always allow tab swipe from screen edges
            const isFromEdge = touchX < edgeThreshold || touchX > screenWidth - edgeThreshold;

            // Allow tab swipe from top zone (section titles area)
            const isFromTopZone = touchY < topZone;

            // Allow tab swipe from bottom zone (near tab bar)
            const isFromBottomZone = touchY > screenHeight - bottomZone;

            tabSwipeStartX = touchX;
            tabSwipeStartY = touchY;
            tabSwipeStartTime = Date.now();
            tabSwipeConfirmed = false;
            tabSwipePending = false;
            tabsTrack.classList.remove('animating');

            if (isFromEdge || isFromTopZone || isFromBottomZone) {
                // Safe zone - definitely a tab swipe
                tabSwiping = true;
            } else {
                // Check if touch started on a swipeable card
                const target = e.target;
                const isOnBacklogItem = target.closest('.backlog-item');
                const isOnFocusCard = target.closest('.focus-card');

                if (isOnBacklogItem || isOnFocusCard) {
                    // Started on card - use pending mode to decide based on gesture
                    tabSwiping = false;
                    tabSwipePending = true;
                } else {
                    tabSwiping = true;
                }
            }
        }, { passive: true });

        tabsContainer.addEventListener('touchmove', e => {
            if (focusVisible) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const diffX = touchX - tabSwipeStartX;
            const diffY = touchY - tabSwipeStartY;
            const elapsed = Date.now() - tabSwipeStartTime;

            // Handle pending swipes (started on card)
            if (tabSwipePending && !tabSwiping) {
                const absX = Math.abs(diffX);
                const absY = Math.abs(diffY);

                // Fast horizontal swipe = tab swipe (velocity check)
                // Speed threshold: 0.5px/ms = fast swipe
                const velocity = absX / Math.max(elapsed, 1);
                const isVeryHorizontal = absX > absY * 3; // More than 3:1 horizontal ratio

                if (absX > 15 && isVeryHorizontal && velocity > 0.4) {
                    // Fast, very horizontal swipe - take over as tab swipe
                    tabSwiping = true;
                    tabSwipePending = false;
                } else if (absX > 30 || absY > 20) {
                    // Gesture has started but not fast/horizontal enough - let card handle it
                    tabSwipePending = false;
                }
            }

            if (!tabSwiping) return;

            // Determine if this is a horizontal swipe
            if (!tabSwipeConfirmed) {
                if (Math.abs(diffY) > Math.abs(diffX) + 10) {
                    tabSwiping = false;
                    return;
                }
                if (Math.abs(diffX) > 10) {
                    tabSwipeConfirmed = true;
                }
            }

            if (tabSwipeConfirmed) {
                // Calculate the new position based on swipe
                const baseOffset = -currentTabIndex * window.innerWidth;
                const newOffset = baseOffset + diffX;

                // Limit swiping at edges
                const minOffset = -(tabIds.length - 1) * window.innerWidth;
                const clampedOffset = Math.max(minOffset, Math.min(0, newOffset));

                tabsTrack.style.transform = `translateX(${clampedOffset}px)`;
            }
        }, { passive: true });

        tabsContainer.addEventListener('touchend', e => {
            tabSwipePending = false;

            if (!tabSwiping) return;
            tabSwiping = false;

            if (!tabSwipeConfirmed || focusVisible) {
                return;
            }

            const diffX = e.changedTouches[0].clientX - tabSwipeStartX;
            const containerWidth = tabsContainer.offsetWidth;
            const swipeThreshold = containerWidth * 0.2; // 20% of screen

            let newIndex = currentTabIndex;
            if (diffX < -swipeThreshold && currentTabIndex < tabIds.length - 1) {
                newIndex = currentTabIndex + 1;
            } else if (diffX > swipeThreshold && currentTabIndex > 0) {
                newIndex = currentTabIndex - 1;
            }

            switchToTab(newIndex);
        });

        // ===== BEDTIME MODE =====
        const bedtimeToggle = document.getElementById('bedtime-toggle');
        const iconMoon = bedtimeToggle.querySelector('.icon-moon');
        const iconSun = bedtimeToggle.querySelector('.icon-sun');
        const settingBedtimeStart = document.getElementById('setting-bedtime-start');
        const settingBedtimeEnd = document.getElementById('setting-bedtime-end');
        let isBedtimeMode = false;

        // Load saved bedtime hours
        const savedBedtimeStart = localStorage.getItem('bedtimeStart') || '21';
        const savedBedtimeEnd = localStorage.getItem('bedtimeEnd') || '6';
        settingBedtimeStart.value = savedBedtimeStart;
        settingBedtimeEnd.value = savedBedtimeEnd;

        settingBedtimeStart.addEventListener('change', function() {
            localStorage.setItem('bedtimeStart', this.value);
            localStorage.removeItem('bedtimeManualOverride');
        });

        settingBedtimeEnd.addEventListener('change', function() {
            localStorage.setItem('bedtimeEnd', this.value);
            localStorage.removeItem('bedtimeManualOverride');
        });

        function checkBedtimeTime() {
            const hour = new Date().getHours();
            const start = parseInt(localStorage.getItem('bedtimeStart') || '21');
            const end = parseInt(localStorage.getItem('bedtimeEnd') || '6');
            return hour >= start || hour < end;
        }

        function updateBedtimeIcon(enabled) {
            iconMoon.style.display = enabled ? 'none' : 'block';
            iconSun.style.display = enabled ? 'block' : 'none';
        }

        function setBedtimeMode(enabled) {
            isBedtimeMode = enabled;
            document.body.classList.toggle('bedtime-mode', enabled);
            updateBedtimeIcon(enabled);
            localStorage.setItem('bedtimeManualOverride', 'true');
            localStorage.setItem('bedtimeMode', enabled.toString());
        }

        function initBedtimeMode() {
            const manualOverride = localStorage.getItem('bedtimeManualOverride');
            const savedMode = localStorage.getItem('bedtimeMode');
            isBedtimeMode = (manualOverride === 'true' && savedMode !== null)
                ? savedMode === 'true'
                : checkBedtimeTime();
            if (isBedtimeMode) {
                document.body.classList.add('bedtime-mode');
                updateBedtimeIcon(true);
            }
        }

        bedtimeToggle.addEventListener('click', () => setBedtimeMode(!isBedtimeMode));
        initBedtimeMode();

        // ===== CONFIRMATION MESSAGES =====
        const confirmationMessages = ["Got it.", "Noted.", "Saved.", "Done.", "All yours.", "On the list.", "Won't forget."];
        const bedtimeMessages = ["Captured.", "Got it.", "Noted.", "Set aside.", "For tomorrow."];
        const worryMessages = ["Heard.", "Got it.", "Noted.", "Okay.", "Captured."];

        function getRandomConfirmation(type = 'normal') {
            if (type === 'worry') {
                return worryMessages[Math.floor(Math.random() * worryMessages.length)];
            }
            const messages = isBedtimeMode ? bedtimeMessages : confirmationMessages;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        // ===== DETECTION =====
        function isWorry(text) {
            const lower = text.toLowerCase();
            const worryPatterns = [
                /^what if\b/,
                /\bworried\b/,
                /\bworry\b/,
                /\banxious\b/,
                /\bscared\b/,
                /\bafraid\b/,
                /\bnervous\b/,
                /\bstressed\b/,
                /\boverwhelmed\b/,
                /\bcan't stop thinking\b/,
                /\bkeep thinking\b/,
                /\bwhat if .+\?$/,
                /^i('m| am) (so )?(worried|scared|afraid|anxious|nervous)/,
            ];
            return worryPatterns.some(pattern => pattern.test(lower));
        }

        function isVague(text) {
            const lower = text.toLowerCase();
            const vaguePatterns = [
                /^(figure out|deal with|handle|look into|sort out|work on|think about|address)\b/,
                /\b(figure out|deal with|handle|look into|sort out|work on|think about|address) .+$/,
                /^(do|fix|finish) (the |my |that )?(thing|stuff)\b/,
            ];
            return vaguePatterns.some(pattern => pattern.test(lower));
        }

        // ===== CAPTURE =====
        const input = document.getElementById('thought-input');
        const bigMicButton = document.getElementById('big-mic-button');
        const micContainer = document.getElementById('mic-container');
        const confirmation = document.getElementById('capture-confirmation');

        function haptic(style) {
            if ('vibrate' in navigator) {
                navigator.vibrate(style === 'light' ? 10 : style === 'medium' ? 20 : 30);
            }
        }

        function showConfirmation(message) {
            confirmation.textContent = message || getRandomConfirmation();
            confirmation.classList.add('visible');
            bigMicButton.classList.add('captured');
            setTimeout(() => {
                confirmation.classList.remove('visible');
                bigMicButton.classList.remove('captured');
            }, 2000);
        }

        function captureThought(text) {
            const thought = (text || input.value).trim();
            if (thought === '') return;
            input.value = '';

            // Check if this is a worry (not an actionable task)
            if (isWorry(thought)) {
                worries.push({
                    text: thought,
                    createdAt: Date.now()
                });
                saveAll();
                showConfirmation(getRandomConfirmation('worry'));
                haptic('light');
                return;
            }

            // It's a task - check if vague
            const vague = isVague(thought);
            thoughts.push({
                text: thought,
                skips: 0,
                createdAt: Date.now(),
                isVague: vague
            });

            // If today's focus isn't full, add to it
            const maxFocus = parseInt(localStorage.getItem('dailyFocusItems') || '3');
            if (todayFocus.length < maxFocus) {
                todayFocus.push({ text: thought, skips: 0, createdAt: Date.now(), isVague: vague });
            }

            saveAll();
            showConfirmation();
            haptic('medium');
        }

        input.addEventListener('keydown', e => {
            if (e.key === 'Enter') captureThought();
        });

        // Voice capture
        let recognition = null;
        let isListening = false;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = function(e) {
                recognition.stop();
                captureThought(e.results[0][0].transcript);
            };

            recognition.onend = function() {
                isListening = false;
                bigMicButton.classList.remove('listening');
                micContainer.classList.remove('listening');
                bigMicButton.textContent = 'tap to capture';
            };

            let voiceUnavailable = false;

            recognition.onerror = function(e) {
                console.log('Speech recognition error:', e.error, e);
                isListening = false;
                bigMicButton.classList.remove('listening');
                micContainer.classList.remove('listening');

                if (e.error === 'not-allowed' || e.error === 'service-not-allowed') {
                    // In iOS standalone PWA, speech service is blocked even with mic permission
                    voiceUnavailable = true;
                    bigMicButton.textContent = 'voice unavailable';
                    bigMicButton.style.fontSize = '14px';
                    document.getElementById('text-input-section').style.bottom = '100px';
                    document.getElementById('thought-input').placeholder = 'type here instead';
                } else if (e.error === 'no-speech') {
                    bigMicButton.textContent = 'no speech heard';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else if (e.error === 'network') {
                    bigMicButton.textContent = 'needs internet';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else if (e.error === 'audio-capture') {
                    bigMicButton.textContent = 'mic unavailable';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                } else {
                    bigMicButton.textContent = e.error || 'error';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                }
            };

            async function startListening() {
                // Request mic permission explicitly first (helps with iOS PWA)
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop()); // Release immediately
                } catch (err) {
                    console.log('Mic permission error:', err);
                    bigMicButton.textContent = 'mic blocked';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                    return;
                }

                try {
                    recognition.start();
                    isListening = true;
                    bigMicButton.classList.add('listening');
                    micContainer.classList.add('listening');
                    bigMicButton.textContent = 'listening...';
                } catch (err) {
                    console.log('Speech start error:', err);
                    bigMicButton.textContent = 'use text below';
                    setTimeout(() => {
                        bigMicButton.textContent = 'tap to capture';
                    }, 2000);
                }
            }

            bigMicButton.addEventListener('click', function() {
                if (voiceUnavailable) {
                    // Focus the text input instead
                    document.getElementById('thought-input').focus();
                    return;
                }
                if (isListening) {
                    recognition.stop();
                } else {
                    startListening();
                }
            });
        } else {
            bigMicButton.disabled = true;
            bigMicButton.textContent = 'voice not supported';
        }

        // ===== FOCUS OVERLAY =====
        const focusOverlay = document.getElementById('focus-overlay');
        const focusHandle = document.getElementById('focus-handle');
        const focusContainer = document.getElementById('focus-cards-container');
        const captureTab = document.getElementById('capture-tab');
        let currentCardIndex = 0;

        function openFocusOverlay() {
            focusVisible = true;
            focusOverlay.classList.add('animating');
            focusOverlay.classList.add('visible');
            focusOverlay.style.transform = '';
            renderFocusCards();
            setTimeout(() => focusOverlay.classList.remove('animating'), 300);
        }

        function closeFocusOverlay() {
            focusVisible = false;
            focusOverlay.classList.add('animating');
            focusOverlay.classList.remove('visible');
            focusOverlay.style.transform = '';
            setTimeout(() => focusOverlay.classList.remove('animating'), 300);
        }

        function renderFocusCards() {
            focusContainer.innerHTML = '';

            // Filter out items already handled today
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));

            if (thoughts.length === 0) {
                focusContainer.innerHTML = `
                    <div id="focus-message">
                        <div id="focus-message-title">nothing here yet</div>
                        <div id="focus-message-subtitle">swipe down to add something</div>
                    </div>`;
                return;
            }

            if (remaining.length === 0) {
                const allDone = todayFocus.length > 0 && completedToday.length === todayFocus.length;
                focusContainer.innerHTML = `
                    <div id="focus-message">
                        <div id="focus-message-title">${allDone ? 'all done' : 'all set'}</div>
                        <div id="focus-message-subtitle">${allDone ? "that's everything" : 'see you tomorrow'}</div>
                    </div>`;
                return;
            }

            // Show all remaining cards
            const total = todayFocus.length;
            const completed = completedToday.length;
            remaining.forEach((item, index) => {
                const cardNum = completed + index + 1;
                const wrapper = document.createElement('div');
                wrapper.className = 'focus-card-wrapper';
                wrapper.innerHTML = `
                    <div class="swipe-bg swipe-bg-left">later</div>
                    <div class="swipe-bg swipe-bg-right">done</div>
                    <div class="focus-card">
                        <div class="focus-progress">${cardNum} of ${total}</div>
                        <div class="focus-card-text">${item.text}</div>
                    </div>
                `;
                setupCardSwipe(wrapper, item);
                focusContainer.appendChild(wrapper);
            });
        }

        function setupCardSwipe(wrapper, item) {
            const card = wrapper.querySelector('.focus-card');
            const bgLeft = wrapper.querySelector('.swipe-bg-left');
            const bgRight = wrapper.querySelector('.swipe-bg-right');
            let startX = 0, currentX = 0, swiping = false;

            card.addEventListener('touchstart', e => {
                startX = e.touches[0].clientX;
                currentX = startX;
                swiping = true;
                card.classList.add('swiping');
            }, { passive: true });

            card.addEventListener('touchmove', e => {
                if (!swiping) return;
                currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                card.style.transform = `translateX(${diff}px)`;

                const threshold = 80;
                if (diff > 0) {
                    bgRight.style.opacity = Math.min(1, diff / threshold);
                    bgLeft.style.opacity = 0;
                } else if (diff < 0) {
                    bgLeft.style.opacity = Math.min(1, -diff / threshold);
                    bgRight.style.opacity = 0;
                } else {
                    bgLeft.style.opacity = 0;
                    bgRight.style.opacity = 0;
                }
            }, { passive: true });

            card.addEventListener('touchend', e => {
                if (!swiping) return;
                swiping = false;
                card.classList.remove('swiping');

                const diff = currentX - startX;

                if (diff > 80) {
                    // Swipe right - done
                    card.style.transform = 'translateX(100vw)';
                    haptic('medium');
                    setTimeout(() => {
                        wrapper.classList.add('removing');
                        setTimeout(() => {
                            completedToday.push(item);
                            thoughts = thoughts.filter(t => t.text !== item.text);
                            completedAllTime.push({
                                text: item.text,
                                completedAt: Date.now(),
                                createdAt: item.createdAt
                            });
                            saveAll();
                            renderFocusCards();
                        }, 300);
                    }, 200);
                } else if (diff < -80) {
                    // Swipe left - later
                    card.style.transform = 'translateX(-100vw)';
                    haptic('light');
                    setTimeout(() => {
                        wrapper.classList.add('removing');
                        setTimeout(() => {
                            laterToday.push(item);
                            const idx = thoughts.findIndex(t => t.text === item.text);
                            if (idx > -1) {
                                const t = thoughts.splice(idx, 1)[0];
                                t.skips = (t.skips || 0) + 1;
                                thoughts.push(t);
                            }
                            saveAll();
                            renderFocusCards();
                        }, 300);
                    }, 200);
                } else {
                    // Snap back
                    card.style.transform = '';
                    bgLeft.style.opacity = 0;
                    bgRight.style.opacity = 0;
                }
            });
        }

        // Swipe up on capture tab to open focus overlay
        let captureStartY = 0, captureDragging = false;

        captureTab.addEventListener('touchstart', e => {
            if (focusVisible) return;
            const touch = e.touches[0];
            // Only trigger from bottom half
            if (touch.clientY > window.innerHeight * 0.5) {
                captureStartY = touch.clientY;
                captureDragging = true;
            }
        }, { passive: true });

        captureTab.addEventListener('touchmove', e => {
            if (!captureDragging || focusVisible) return;
            const diff = captureStartY - e.touches[0].clientY;
            if (diff > 10) {
                const progress = Math.min(diff / (window.innerHeight * 0.5), 1);
                focusOverlay.style.transform = `translateY(${(1 - progress) * 100}%)`;
            }
        }, { passive: true });

        captureTab.addEventListener('touchend', e => {
            if (!captureDragging) return;
            captureDragging = false;
            const diff = captureStartY - e.changedTouches[0].clientY;
            if (diff > 100) {
                openFocusOverlay();
            } else {
                focusOverlay.style.transform = '';
            }
        });

        // Swipe down anywhere on focus overlay to close
        let overlayStartY = 0, overlayStartX = 0, overlayDragging = false, overlayDragConfirmed = false;

        focusOverlay.addEventListener('touchstart', e => {
            overlayStartY = e.touches[0].clientY;
            overlayStartX = e.touches[0].clientX;
            overlayDragging = true;
            overlayDragConfirmed = false;
        }, { passive: true });

        focusOverlay.addEventListener('touchmove', e => {
            if (!overlayDragging) return;

            const diffY = e.touches[0].clientY - overlayStartY;
            const diffX = e.touches[0].clientX - overlayStartX;

            // Only handle if vertical swipe is dominant and downward
            if (!overlayDragConfirmed) {
                if (Math.abs(diffX) > 20) {
                    // Horizontal swipe - let card handle it
                    overlayDragging = false;
                    return;
                }
                if (diffY > 20) {
                    overlayDragConfirmed = true;
                }
            }

            if (overlayDragConfirmed && diffY > 0) {
                focusOverlay.style.transform = `translateY(${diffY}px)`;
            }
        }, { passive: true });

        focusOverlay.addEventListener('touchend', e => {
            if (!overlayDragging) return;
            overlayDragging = false;

            if (!overlayDragConfirmed) {
                return;
            }

            const diff = e.changedTouches[0].clientY - overlayStartY;
            if (diff > 100) {
                closeFocusOverlay();
            } else {
                focusOverlay.classList.add('animating');
                focusOverlay.style.transform = '';
                setTimeout(() => focusOverlay.classList.remove('animating'), 300);
            }
        });

        // ===== TODAY TAB =====
        const laterList = document.getElementById('later-list');
        const completedTodayList = document.getElementById('completed-today-list');
        const oldItemsSection = document.getElementById('old-items-section');
        const oldItemsList = document.getElementById('old-items-list');

        function getTimeAgo(timestamp) {
            const days = Math.floor((Date.now() - timestamp) / (1000 * 60 * 60 * 24));
            if (days < 7) return `${days} day${days !== 1 ? 's' : ''} ago`;
            const weeks = Math.floor(days / 7);
            return `${weeks} week${weeks !== 1 ? 's' : ''} ago`;
        }

        function addToTodayFocus(item) {
            // Add to today's focus if not already there
            if (!todayFocus.find(t => t.text === item.text)) {
                todayFocus.push({ ...item });
                saveAll();
                renderTodayTab();
                renderFocusCards();
                haptic('light');
            }
        }

        function renderTodayTab() {
            // Old items (2+ weeks old, not in today's focus)
            const twoWeeksAgo = Date.now() - (14 * 24 * 60 * 60 * 1000);
            const focusTexts = todayFocus.map(t => t.text);
            const oldItems = thoughts
                .filter(t => t.createdAt && t.createdAt < twoWeeksAgo && !focusTexts.includes(t.text))
                .slice(0, 2);

            if (oldItems.length > 0) {
                oldItemsSection.style.display = 'block';
                oldItemsList.innerHTML = '';
                oldItems.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'task-item old tappable';
                    li.innerHTML = `
                        ${item.text}
                        <div class="task-item-age">${getTimeAgo(item.createdAt)}  tap to focus</div>
                    `;
                    li.addEventListener('click', () => addToTodayFocus(item));
                    oldItemsList.appendChild(li);
                });
            } else {
                oldItemsSection.style.display = 'none';
            }

            // For later
            laterList.innerHTML = laterToday.length === 0
                ? '<li class="empty-section">nothing pushed back</li>'
                : laterToday.map(item => `<li class="task-item later">${item.text}</li>`).join('');

            // Completed
            completedTodayList.innerHTML = completedToday.length === 0
                ? '<li class="empty-section"></li>'
                : completedToday.map(item => `<li class="task-item completed">${item.text}</li>`).join('');
        }

        // ===== ALL TAB =====
        const backlogList = document.getElementById('backlog-list');
        let draggedItem = null;
        let draggedIndex = -1;
        let placeholder = null;

        function renderAllTab() {
            // Show thoughts not in today's focus
            const focusTexts = todayFocus.map(t => t.text);
            const backlog = thoughts.filter(t => !focusTexts.includes(t.text));

            if (backlog.length === 0) {
                backlogList.innerHTML = '<div class="empty-section">nothing waiting</div>';
                return;
            }

            backlogList.innerHTML = '';
            backlog.forEach((item, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'backlog-item-wrapper';
                wrapper.dataset.index = index;

                // Build meta info
                let metaHtml = '';
                const metaParts = [];
                if (item.createdAt) {
                    const daysAgo = Math.floor((Date.now() - item.createdAt) / (1000 * 60 * 60 * 24));
                    if (daysAgo === 0) metaParts.push('today');
                    else if (daysAgo === 1) metaParts.push('yesterday');
                    else if (daysAgo < 7) metaParts.push(`${daysAgo} days ago`);
                    else if (daysAgo < 14) metaParts.push('1 week ago');
                    else metaParts.push(`${Math.floor(daysAgo / 7)} weeks ago`);
                }
                if (item.skips > 0) metaParts.push(`deferred ${item.skips}x`);
                if (metaParts.length > 0) {
                    metaHtml = `<div class="backlog-item-meta">${metaParts.map(p => `<span>${p}</span>`).join('')}</div>`;
                }

                wrapper.innerHTML = `
                    <div class="backlog-swipe-bg backlog-swipe-delete">delete</div>
                    <div class="backlog-item">
                        <div class="backlog-item-text">${item.text}</div>
                        ${metaHtml}
                    </div>
                `;
                setupBacklogInteraction(wrapper, item, index, backlog);
                backlogList.appendChild(wrapper);
            });
        }

        function setupBacklogInteraction(wrapper, item, originalIndex, backlog) {
            const itemEl = wrapper.querySelector('.backlog-item');
            const deleteBg = wrapper.querySelector('.backlog-swipe-delete');

            let startX = 0, startY = 0, currentX = 0, currentY = 0;
            let swiping = false, dragging = false, pendingDelete = false;
            let longPressTimer = null;
            let wrapperRect = null;
            let allWrappers = [];
            const LONG_PRESS_DURATION = 400;

            function confirmDelete() {
                itemEl.style.transform = 'translateX(-100vw)';
                haptic('medium');
                setTimeout(() => {
                    wrapper.classList.add('removing');
                    setTimeout(() => {
                        thoughts = thoughts.filter(t => t.text !== item.text);
                        todayFocus = todayFocus.filter(t => t.text !== item.text);
                        saveAll();
                        renderAllTab();
                        renderFocusCards();
                    }, 300);
                }, 150);
            }

            function cancelPendingDelete() {
                pendingDelete = false;
                deleteBg.classList.remove('confirm');
                deleteBg.textContent = 'delete';
                itemEl.style.transform = '';
                deleteBg.style.opacity = 0;
            }

            // Tap on delete background to confirm
            deleteBg.addEventListener('click', e => {
                if (pendingDelete) {
                    e.stopPropagation();
                    confirmDelete();
                }
            });

            function startDragMode(e) {
                dragging = true;
                swiping = false;
                draggedItem = item;
                draggedIndex = originalIndex;

                wrapperRect = wrapper.getBoundingClientRect();
                allWrappers = Array.from(backlogList.querySelectorAll('.backlog-item-wrapper'));

                // Create placeholder
                placeholder = document.createElement('div');
                placeholder.className = 'backlog-placeholder';
                placeholder.style.height = wrapperRect.height + 'px';

                // Style dragged item
                wrapper.classList.add('dragging');
                wrapper.style.position = 'fixed';
                wrapper.style.left = wrapperRect.left + 'px';
                wrapper.style.top = wrapperRect.top + 'px';
                wrapper.style.width = wrapperRect.width + 'px';
                wrapper.style.zIndex = '100';

                // Insert placeholder
                wrapper.parentNode.insertBefore(placeholder, wrapper);
                document.body.appendChild(wrapper);

                haptic('medium');
            }

            itemEl.addEventListener('touchstart', e => {
                // Cancel any pending delete when starting new interaction
                if (pendingDelete) {
                    cancelPendingDelete();
                }

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                currentX = startX;
                currentY = startY;
                swiping = true;
                itemEl.classList.add('swiping');

                // Start long press timer
                longPressTimer = setTimeout(() => {
                    if (swiping && Math.abs(currentX - startX) < 10 && Math.abs(currentY - startY) < 10) {
                        startDragMode(e);
                    }
                }, LONG_PRESS_DURATION);
            }, { passive: true });

            itemEl.addEventListener('touchmove', e => {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;

                // If moved too much, cancel long press
                if (longPressTimer && (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startY) > 10)) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (dragging) {
                    // Drag mode - move vertically
                    const diff = currentY - startY;
                    wrapper.style.top = (wrapperRect.top + diff) + 'px';

                    // Find where to insert placeholder
                    const wrapperCenterY = wrapperRect.top + diff + wrapperRect.height / 2;
                    let insertBefore = null;

                    allWrappers.forEach(w => {
                        if (w === wrapper) return;
                        const rect = w.getBoundingClientRect();
                        if (wrapperCenterY < rect.top + rect.height / 2) {
                            if (!insertBefore || rect.top < insertBefore.getBoundingClientRect().top) {
                                insertBefore = w;
                            }
                        }
                    });

                    // Move placeholder
                    if (insertBefore) {
                        backlogList.insertBefore(placeholder, insertBefore);
                    } else {
                        backlogList.appendChild(placeholder);
                    }
                } else if (swiping) {
                    // Swipe mode - move horizontally (left only)
                    const diffX = currentX - startX;
                    if (diffX < 0) {
                        itemEl.style.transform = `translateX(${diffX}px)`;
                        const opacity = Math.min(1, (-diffX - 30) / 50);
                        deleteBg.style.opacity = Math.max(0, opacity);
                    }
                }
            }, { passive: true });

            itemEl.addEventListener('touchend', e => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (dragging) {
                    // End drag mode
                    dragging = false;

                    // Get new position based on placeholder
                    const newIndex = Array.from(backlogList.children).indexOf(placeholder);

                    // Reset wrapper styling
                    wrapper.classList.remove('dragging');
                    wrapper.style.position = '';
                    wrapper.style.left = '';
                    wrapper.style.top = '';
                    wrapper.style.width = '';
                    wrapper.style.zIndex = '';

                    // Insert at new position
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.insertBefore(wrapper, placeholder);
                        placeholder.remove();
                    }
                    placeholder = null;

                    // Update thoughts array
                    if (newIndex !== -1 && newIndex !== originalIndex) {
                        const focusTexts = todayFocus.map(t => t.text);
                        const backlogItems = thoughts.filter(t => !focusTexts.includes(t.text));
                        const movedItem = backlogItems[originalIndex];

                        // Remove from original position in thoughts
                        const thoughtsIndex = thoughts.findIndex(t => t.text === movedItem.text);
                        if (thoughtsIndex > -1) {
                            thoughts.splice(thoughtsIndex, 1);
                        }

                        // Find insert position in thoughts (after focus items)
                        const focusCount = thoughts.filter(t => focusTexts.includes(t.text)).length;
                        const insertAt = focusCount + newIndex;
                        thoughts.splice(insertAt, 0, movedItem);

                        saveAll();
                        haptic('light');
                    }

                    draggedItem = null;
                    draggedIndex = -1;
                } else if (swiping) {
                    // End swipe mode
                    swiping = false;
                    itemEl.classList.remove('swiping');

                    const diffX = currentX - startX;
                    const diffY = currentY - startY;

                    if (diffX < -100) {
                        // Show delete confirmation
                        pendingDelete = true;
                        const itemWidth = itemEl.offsetWidth;
                        itemEl.style.transform = `translateX(-${itemWidth}px)`;
                        deleteBg.style.opacity = 1;
                        deleteBg.classList.add('confirm');
                        deleteBg.textContent = 'tap to delete';
                        haptic('light');
                    } else if (Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
                        // Simple tap - add to today's focus
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                        addToTodayFocus(item);
                    } else {
                        // Snap back
                        itemEl.style.transform = '';
                        deleteBg.style.opacity = 0;
                    }
                }
            });

            // Handle touch cancel
            itemEl.addEventListener('touchcancel', () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                swiping = false;
                dragging = false;
                if (pendingDelete) cancelPendingDelete();
                itemEl.classList.remove('swiping');
                wrapper.classList.remove('dragging');
                itemEl.style.transform = '';
                deleteBg.style.opacity = 0;
            });
        }

        // ===== MORNING INTENTION =====
        const morningBanner = document.getElementById('morning-banner');
        const morningFocusList = document.getElementById('morning-focus-list');
        const morningClose = document.getElementById('morning-close');
        const morningAction = document.getElementById('morning-action');

        function isMorningTime() {
            const hour = new Date().getHours();
            return hour >= 6 && hour < 10;
        }

        function showMorningBanner() {
            // Check if already dismissed today
            const dismissedDate = localStorage.getItem('morningDismissed');
            if (dismissedDate === getTodayDate()) return;

            // Check if morning time
            if (!isMorningTime()) return;

            // Check if there are focus items
            if (todayFocus.length === 0) return;

            // Populate focus list
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));

            if (remaining.length === 0) return;

            morningFocusList.innerHTML = remaining.slice(0, 3).map(item =>
                `<div class="morning-focus-preview">${item.text}</div>`
            ).join('');

            morningBanner.classList.add('visible');
        }

        function dismissMorning() {
            morningBanner.classList.remove('visible');
            localStorage.setItem('morningDismissed', getTodayDate());
        }

        morningClose.addEventListener('click', dismissMorning);
        morningAction.addEventListener('click', () => {
            dismissMorning();
            openFocusOverlay();
        });

        // Show morning banner on load
        showMorningBanner();

        // ===== WEEKLY REFLECTION =====
        const weeklyBanner = document.getElementById('weekly-banner');
        const weeklyClose = document.getElementById('weekly-close');
        const weeklyAction = document.getElementById('weekly-action');
        const weeklyCompleted = document.getElementById('weekly-completed');
        const weeklyCaptured = document.getElementById('weekly-captured');

        function getWeekNumber(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            const yearStart = new Date(d.getFullYear(), 0, 1);
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function getWeekKey() {
            const now = new Date();
            return `${now.getFullYear()}-W${getWeekNumber(now)}`;
        }

        function isSundayEvening() {
            const now = new Date();
            return now.getDay() === 0 && now.getHours() >= 17;
        }

        function getWeeklyStats() {
            const now = Date.now();
            const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);

            const completed = completedAllTime.filter(t => t.completedAt && t.completedAt > oneWeekAgo).length;
            const captured = [
                ...thoughts.filter(t => t.createdAt && t.createdAt > oneWeekAgo),
                ...completedAllTime.filter(t => t.createdAt && t.createdAt > oneWeekAgo),
                ...worries.filter(w => w.createdAt && w.createdAt > oneWeekAgo)
            ].length;

            return { completed, captured };
        }

        function showWeeklyBanner() {
            // Check if already reflected this week
            const weekKey = getWeekKey();
            const existingReflection = weeklyReflections.find(r => r.week === weekKey);
            if (existingReflection) return;

            // Check if Sunday evening
            if (!isSundayEvening()) return;

            // Check if dismissed this session
            if (localStorage.getItem('weeklyDismissed') === weekKey) return;

            // Don't show if morning banner is visible
            if (morningBanner.classList.contains('visible')) return;

            const stats = getWeeklyStats();
            if (stats.completed === 0 && stats.captured === 0) return;

            weeklyCompleted.textContent = stats.completed;
            weeklyCaptured.textContent = stats.captured;

            weeklyBanner.classList.add('visible');
        }

        function dismissWeekly() {
            weeklyBanner.classList.remove('visible');
            localStorage.setItem('weeklyDismissed', getWeekKey());
        }

        function saveWeeklyReflection() {
            const stats = getWeeklyStats();
            const weekKey = getWeekKey();

            // Don't save duplicate
            if (weeklyReflections.find(r => r.week === weekKey)) {
                dismissWeekly();
                switchToTab(3); // Go to patterns tab
                return;
            }

            weeklyReflections.unshift({
                week: weekKey,
                date: Date.now(),
                completed: stats.completed,
                captured: stats.captured
            });

            // Keep only last 12 weeks
            weeklyReflections = weeklyReflections.slice(0, 12);

            saveAll();
            dismissWeekly();
            switchToTab(3); // Go to patterns tab
        }

        weeklyClose.addEventListener('click', dismissWeekly);
        weeklyAction.addEventListener('click', saveWeeklyReflection);

        // Show weekly banner on load (after morning check)
        setTimeout(showWeeklyBanner, 100);

        // ===== BACKUP/RESTORE =====
        function updateLastBackupInfo() {
            const lastBackup = localStorage.getItem('lastBackupDate');
            const infoEl = document.getElementById('last-backup-info');
            if (lastBackup) {
                const date = new Date(parseInt(lastBackup));
                const daysAgo = Math.floor((Date.now() - date) / (1000 * 60 * 60 * 24));
                let timeStr;
                if (daysAgo === 0) timeStr = 'today';
                else if (daysAgo === 1) timeStr = 'yesterday';
                else if (daysAgo < 7) timeStr = `${daysAgo} days ago`;
                else timeStr = `${Math.floor(daysAgo / 7)} week${daysAgo >= 14 ? 's' : ''} ago`;
                infoEl.textContent = `Last backup: ${timeStr}`;
                if (daysAgo >= 7) {
                    infoEl.style.color = 'var(--later-color)';
                }
            } else {
                infoEl.textContent = 'No backups yet';
                infoEl.style.color = 'var(--later-color)';
            }
        }

        window.backupToClipboard = async function() {
            const data = {
                thoughts,
                todayFocus,
                laterToday,
                completedToday,
                completedAllTime,
                worries,
                weeklyReflections,
                lastResetDate,
                backupDate: new Date().toISOString(),
                version: 1
            };

            try {
                await navigator.clipboard.writeText(JSON.stringify(data));
                localStorage.setItem('lastBackupDate', Date.now().toString());
                updateLastBackupInfo();
                alert('Backup copied to clipboard! Paste it somewhere safe (Notes, email, etc.)');
            } catch (err) {
                // Fallback for iOS
                const textArea = document.createElement('textarea');
                textArea.value = JSON.stringify(data);
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    localStorage.setItem('lastBackupDate', Date.now().toString());
                    updateLastBackupInfo();
                    alert('Backup copied! Paste it somewhere safe.');
                } catch (e) {
                    alert('Could not copy. Try the Export option in Dev Tools instead.');
                }
                document.body.removeChild(textArea);
            }
        };

        window.restoreFromClipboard = async function() {
            let text;
            try {
                text = await navigator.clipboard.readText();
            } catch (err) {
                text = prompt('Paste your backup data here:');
            }

            if (!text) return;

            try {
                const data = JSON.parse(text);

                // Validate it looks like our data
                if (!data.thoughts || !Array.isArray(data.thoughts)) {
                    alert('Invalid backup data');
                    return;
                }

                if (!confirm(`Restore backup from ${data.backupDate ? new Date(data.backupDate).toLocaleDateString() : 'unknown date'}? This will replace all current data.`)) {
                    return;
                }

                thoughts = data.thoughts || [];
                todayFocus = data.todayFocus || [];
                laterToday = data.laterToday || [];
                completedToday = data.completedToday || [];
                completedAllTime = data.completedAllTime || [];
                worries = data.worries || [];
                weeklyReflections = data.weeklyReflections || [];
                lastResetDate = data.lastResetDate || '';

                saveAll();
                alert('Restored successfully!');
                location.reload();
            } catch (e) {
                alert('Could not parse backup data. Make sure you copied the entire backup.');
            }
        };

        // Update backup info on settings open
        settingsToggle.addEventListener('click', updateLastBackupInfo);

        // ===== DEV TOOLS =====
        window.devGenerateThoughts = function() {
            const sampleThoughts = [
                'Review quarterly goals',
                'Call mom about weekend plans',
                'Research new project management tools',
                'Schedule dentist appointment',
                'Update resume',
                'Clean out garage',
                'Plan team offsite',
                'Read that book everyone recommended',
                'Fix the leaky faucet',
                'Organize photo library'
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            sampleThoughts.forEach((text, i) => {
                const daysAgo = Math.floor(Math.random() * 21) + 1; // 1-21 days ago
                thoughts.push({
                    text,
                    skips: 0,
                    createdAt: now - (daysAgo * dayMs)
                });
            });
            selectTodayFocus();
            saveAll();
            alert('Added 10 sample thoughts');
        };

        window.devGenerateCompleted = function() {
            const sampleCompleted = [
                'Submit expense report',
                'Buy birthday gift',
                'Finish presentation',
                'Reply to emails',
                'Update project status',
                'Review pull request',
                'Book flight tickets',
                'Send meeting notes',
                'Fix bug in login flow',
                'Write blog post draft',
                'Clean desk',
                'Update dependencies',
                'Call insurance company',
                'Prepare demo',
                'Order office supplies'
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            sampleCompleted.forEach((text, i) => {
                const daysAgo = Math.floor(Math.random() * 14); // 0-13 days ago
                completedAllTime.push({
                    text,
                    createdAt: now - ((daysAgo + 1) * dayMs),
                    completedAt: now - (daysAgo * dayMs)
                });
            });
            saveAll();
            alert('Added 15 completed items');
        };

        window.devGenerateWorries = function() {
            const sampleWorries = [
                'What if the project fails?',
                'Worried about the presentation tomorrow',
                'Anxious about the upcoming review',
                'Keep thinking about that awkward conversation',
                'Stressed about deadlines'
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            sampleWorries.forEach((text, i) => {
                const daysAgo = Math.floor(Math.random() * 14);
                worries.push({
                    text,
                    createdAt: now - (daysAgo * dayMs)
                });
            });
            saveAll();
            alert('Added 5 worries');
        };

        window.devGenerateSkipped = function() {
            const skippedItems = [
                { text: 'Organize the basement', skips: 5 },
                { text: 'Start exercising regularly', skips: 4 },
                { text: 'Learn a new language', skips: 3 }
            ];
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            skippedItems.forEach(item => {
                thoughts.push({
                    text: item.text,
                    skips: item.skips,
                    createdAt: now - (14 * dayMs)
                });
            });
            selectTodayFocus();
            saveAll();
            alert('Added 3 frequently skipped items');
        };

        window.devGenerateReflections = function() {
            const now = Date.now();
            const weekMs = 7 * 24 * 60 * 60 * 1000;

            for (let i = 1; i <= 4; i++) {
                const weekDate = new Date(now - (i * weekMs));
                const weekNum = getWeekNumber(weekDate);
                const weekKey = `${weekDate.getFullYear()}-W${weekNum}`;

                // Don't duplicate
                if (!weeklyReflections.find(r => r.week === weekKey)) {
                    weeklyReflections.push({
                        week: weekKey,
                        date: weekDate.getTime(),
                        completed: Math.floor(Math.random() * 8) + 2,
                        captured: Math.floor(Math.random() * 12) + 5
                    });
                }
            }
            // Sort by date descending
            weeklyReflections.sort((a, b) => b.date - a.date);
            saveAll();
            alert('Added 4 weeks of reflections');
        };

        window.devTriggerMorning = function() {
            localStorage.removeItem('morningDismissed');
            // Force show
            if (todayFocus.length === 0 && thoughts.length > 0) {
                selectTodayFocus();
                saveAll();
            }
            if (todayFocus.length === 0) {
                alert('Add some thoughts first');
                return;
            }
            const handledTexts = [...laterToday.map(i => i.text), ...completedToday.map(i => i.text)];
            const remaining = todayFocus.filter(item => !handledTexts.includes(item.text));
            if (remaining.length === 0) {
                alert('All focus items already handled today');
                return;
            }
            morningFocusList.innerHTML = remaining.slice(0, 3).map(item =>
                `<div class="morning-focus-preview">${item.text}</div>`
            ).join('');
            morningBanner.classList.add('visible');
            settingsPanel.classList.remove('visible');
        };

        window.devTriggerWeekly = function() {
            localStorage.removeItem('weeklyDismissed');
            const stats = getWeeklyStats();
            if (stats.completed === 0 && stats.captured === 0) {
                alert('Generate some data first');
                return;
            }
            weeklyCompleted.textContent = stats.completed;
            weeklyCaptured.textContent = stats.captured;
            weeklyBanner.classList.add('visible');
            morningBanner.classList.remove('visible');
            settingsPanel.classList.remove('visible');
        };

        window.devExportData = function() {
            const data = {
                thoughts,
                todayFocus,
                laterToday,
                completedToday,
                completedAllTime,
                worries,
                weeklyReflections,
                lastResetDate,
                exportedAt: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `daily-overwhelm-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        };

        window.devClearAllData = function() {
            if (!confirm('This will delete ALL your data. Are you sure?')) return;
            if (!confirm('Really sure? This cannot be undone.')) return;

            thoughts = [];
            todayFocus = [];
            laterToday = [];
            completedToday = [];
            completedAllTime = [];
            worries = [];
            weeklyReflections = [];
            lastResetDate = '';

            localStorage.clear();
            saveAll();

            alert('All data cleared');
            location.reload();
        };

        // ===== SERVICE WORKER =====
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('Service Worker registration failed:', err));
        }

        // Check for daily reset periodically
        setInterval(checkDailyReset, 60000);
    </script>
</body>
</html>
